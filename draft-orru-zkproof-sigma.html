<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>Sigma Protocols</title>
<meta content="Michele Orrù" name="author">
<meta content="Stephan Krenn" name="author">
<meta content="
       This document describes Sigma protocols, a secure, general-purpose non-interactive zero-knowledge proof of knowledge. Concretely, the scheme allows proving knowledge of the pre-representation of different group elements, without revealing any information about the undisclosed messages or the signature itself, while at the same time, guarantying soundness of the overall protocols. 
    " name="description">
<meta content="xml2rfc 3.20.1" name="generator">
<meta content="zero-knowledge" name="keyword">
<meta content="draft-orru-zkproof-sigma-latest" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.20.1
    Python 3.11.8
    ConfigArgParse 1.7
    google-i18n-address 3.1.0
    intervaltree 3.1.0
    Jinja2 3.1.2
    lxml 4.9.3
    platformdirs 4.2.0
    pycountry 22.3.5
    PyYAML 6.0.1
    requests 2.31.0
    setuptools 68.2.2
    six 1.16.0
    wcwidth 0.2.13
-->
<link href="draft-orru-zkproof-sigma.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}

@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Lora SemiBold'), local('Lora-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  color-scheme: light dark;
  --background-color: #fff;
  --text-color: #222;
  --title-color: #191919;
  --link-color: #2a6496;
  --highlight-color: #f9f9f9;
  --line-color: #eee;
  --pilcrow-weak: #ddd;
  --pilcrow-strong: #bbb;
  --small-font-size: 14.5px;
  --font-mono: 'Oxygen Mono', monospace;
  scrollbar-color: #bbb #eee;
}
body {
  max-width: 600px;
  margin: 75px auto;
  padding: 0 5px;
  color: var(--text-color);
  background-color: var(--background-color);
  font: 16px/22px "Lora", serif;
  scroll-behavior: smooth;
}

.ears {
  display: none;
}

/* headings */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cabin Condensed", sans-serif;
  font-weight: 600;
  margin: 0.8em 0 0.3em;
  font-size-adjust: 0.5;
  color: var(--title-color);
}
h1#title {
  font-size: 32px;
  line-height: 40px;
  clear: both;
}
h1#title, h1#rfcnum {
  margin: 1.5em 0 0.2em;
}
h1#rfcnum + h1#title {
  margin: 0.2em 0;
}

h1, h2, h3 {
  font-size: 22px;
  line-height: 27px;
}
h4, h5, h6 {
  font-size: 20px;
  line-height: 24px;
}

/* general structure */
.author {
  padding-bottom: 0.3em;
}
#abstract+p {
  font-size: 18px;
  line-height: 24px;
}
#abstract+p code, #abstract+p samp, #abstract+p tt {
  font-size: 16px;
  line-height: 0;
}

p {
  padding: 0;
  margin: 0.5em 0;
  text-align: left;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignRight.art-text pre {
  padding: 0;
  width: auto;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
/* font-family isn't space-separated, but =~ will have to do */
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignCenter.art-text pre {
  padding: 0;
  width: auto;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 0.5em 2em;
}
:is(ol, ul) :is(ol, ul) {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
:is(ul, ol).compact, .ulCompact, .olCompact {
  line-height: 1;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
  clear: left;
  --indent: 3ch;
  /* --indent: attr(indent ch); not supported in any browser, but we can dream */
}
dl.olPercent {
  --indent: 5ch;
}
dl > dt {
  float: left;
  margin-right: 2ch;
  min-width: 8ch;
}
dl.dlNewline > dt {
  float: none;
}
dl > dd {
  margin-bottom: .8em;
  margin-left: var(--indent) !important; /* stupid element overrides */
  min-height: 2ex;
}
dl.olPercent > dt {
  min-width: calc(var(--indent) - 2ch);
}
:is(dl.compact, .dlCompact) > dd {
  margin-bottom: 0;
}
:is(dl.compact, .dlCompact) > dd > :is(:first-child, .break:first-child + *) {
  margin-top: 0;
}
:is(dl.compact, .dlCompact) > dd > :is(:last-child) {
  margin-bottom: 0;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0;
}
:is(dd, span).break {
  display: none;
}

/* links */
a, a[href].selfRef:hover {
  text-decoration: none;
}
a[href] {
  color: var(--link-color);
}
a[href].selfRef, .iref + a[href].internal {
  color: var(--text-color);
}
a[href]:hover {
  text-decoration: underline;
}
a[href].selfRef:hover {
  background-color: var(--highlight-color);
}
a.xref:is(.cite, .auto), :is(#status-of-memo, #copyright) a {
  white-space: nowrap;
}

/* Figures */
tt, code, pre {
  background-color: var(--highlight-color);
  font: 14px/22px var(--font-mono);
}
tt, code {
  /* changing the font for inline elements leads to different ascender
     and descender heights; as we want to retain baseline alignment,
     remove leading to avoid altering the final height of lines
     note: this fails if these blocks take an entire line,
     a different solution would be great */
  line-height: 0;
}
:is(h1, h2, h3, h4, h5, h6) :is(tt, code) {
  font-size: 84%;
}
pre {
  border: 1px solid var(--line-color);
  font-size: 13.5px;
  line-height: 16px;
  letter-spacing: -0.2px;
  margin: 5px;
  padding: 5px;
}
img {
  max-width: 100%;
}
figure {
  margin: 0.5em 0;
  padding: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption, caption {
  font-style: italic;
  margin: 0.5em 1.5em;
  text-align: left;
}
@media screen {
  /* Auto-collapse boilerplate. */
  :is(#status-of-memo, #copyright) p {
    margin: -2px 0;
    max-height: 0;
    transition: max-height 2s ease, margin 0.5s ease 0.5s;
    overflow: hidden;
  }
  :is(#status-of-memo, #copyright):hover p,
  :is(#status-of-memo, #copyright) h2:target ~ p {
    margin: 0.5em 0;
    max-height: 500px;
    overflow: auto;
  }
  pre, svg {
    display: inline-block;
    overflow-x: auto;
  }
  pre {
    max-width: 100%;
    width: calc(100% - 22px - 1em);
  }
  svg {
    max-width: calc(100% - 22px - 1em);
  }
  figure pre {
    display: block;
    width: calc(100% - 25px);
  }
  :is(pre, svg) + .pilcrow {
    display: inline-block;
    vertical-align: text-bottom;
    padding-bottom: 8px;
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 0 2em;
  font-style: italic;
}
blockquote {
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  max-width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
table.left {
  margin-right: auto;
}
thead, tbody {
  border: 1px solid var(--line-color);
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 5px 10px;
}
th {
  background-color: var(--line-color);
}
:is(tr:nth-child(2n), thead+tbody > tr:nth-child(2n+1)) > td {
  background-color: var(--background-color);
}
:is(tr:nth-child(2n+1), thead+tbody > tr:nth-child(2n)) > td {
  background-color: var(--highlight-color);
}
table caption {
  margin: 0;
  padding: 3px 0 3px 1em;
}
table p {
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  margin-left: 3px;
  opacity: 0.2;
  user-select: none;
}
a.pilcrow[href] { color: var(--pilcrow-weak); }
a.pilcrow[href]:hover { text-decoration: none; }
@media not print {
  :hover > a.pilcrow {
    opacity: 1;
  }
  a.pilcrow[href]:hover {
    color: var(--pilcrow-strong);
    background-color: transparent;
  }
}
@media print {
  a.pilcrow {
    display: none;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid var(--line-color);
}
.bcp14 {
  font-variant: small-caps;
  font-weight: 600;
  font-size: var(--small-font-size);
}
.role {
  font-variant: all-small-caps;
}
sub, sup {
  line-height: 1;
  font-size: 80%;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: var(--small-font-size);
  line-height: 18px;
  --identifier-width: 15ch;
}
#identifiers dt {
  width: var(--identifier-width);
  min-width: var(--identifier-width);
  clear: left;
  float: left;
  text-align: right;
  margin-right: 1ch;
}
#identifiers dd {
  margin: 0;
  margin-left: calc(1em + var(--identifier-width)) !important;
  min-width: 5em;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #999;
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
#toc nav ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
#toc nav li {
  line-height: 1.3em;
  margin: 2px 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
#toc a.xref {
  white-space: normal;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 10ch;
  margin-right: 1.5ch;
}
.references dt:target::before {
  content: "⇒";
  width: 15px;
  margin: 0 10px 0 -25px;
}
.references dd {
  margin-left: 12ch !important;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
#rfc\.index\.index + ul {
  margin-left: 0;
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}
address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}
@media (min-width: 500px) {
  #authors-addresses > section {
    column-count: 2;
    column-gap: 20px;
  }
  #authors-addresses > section > h2 {
    column-span: all;
  }
  /* hack for break-inside: avoid-column */
  #authors-addresses address {
    display: inline-block;
    break-inside: avoid-column;
  }
}

.rfcEditorRemove p:first-of-type {
  font-style: italic;
}
.cref {
  background-color: rgba(249, 232, 105, 0.3);
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 929px) {
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 1px 0 0 0;
    margin: 0;
    border-bottom: 1px solid #ccc;
    opacity: 0.6;
  }
  #toc.active {
      opacity: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 2px 0 2px 6px;
    padding-right: 1em;
    font-size: 18px;
    line-height: 24px;
    min-width: 190px;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 8px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    background-color: var(--background-color);
    padding: 0.5em 1em 1em;
    overflow: auto;
    overscroll-behavior: contain;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
  #toc.active nav {
    display: block;
  }
  /* Make the collapsed ToC header render white on gray also when it's a link */
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
  #toc a.toplink {
    margin-top: 2px;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 930px) {
  body {
    padding-right: 360px;
    padding-right: calc(min(180px + 20%, 500px));
  }
  #toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 480px);
    width: 312px;
    margin: 0;
    padding: 0;
    z-index: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 2em;
    overflow: auto;
    overscroll-behavior: contain;
    scrollbar-width: thin;
  }
  #toc nav > ul  {
    margin-bottom: 2em;
  }
  #toc ul {
    margin: 0 0 0 4px;
    font-size: var(--small-font-size);
  }
  #toc ul :is(p, li) {
    margin: 2px 0;
    line-height: 22px;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre, .vcard {
    page-break-inside: avoid;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  :is(h2, h3, h4, h5, h6)+*, dd {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
  .toplink {
    display: none;
  }
}

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
}

/* Changes introduced to fix issues found during implementation */

/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}

/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin: 8px 0.5em 0;
}

/* Provide styling for table cell text alignment */
table .text-left {
  text-align: left;
}
table .text-center {
  text-align: center;
}
table .text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 20em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Dark mode. */
@media (prefers-color-scheme: dark) {
:root {
  --background-color: #121212;
  --text-color: #f0f0f0;
  --title-color: #fff;
  --link-color: #4da4f0;
  --highlight-color: #282828;
  --line-color: #444;
  --pilcrow-weak: #444;
  --pilcrow-strong: #666;
  scrollbar-color: #777 #333;
}
}

/* SVG Trick: a prefix match works because only black and white are allowed */
svg :is([stroke="black"], [stroke^="#000"]) {
  stroke: var(--text-color);
}
svg :is([stroke="white"], [stroke^="#fff"]) {
  stroke: var(--background-color);
}
svg :is([fill="black"], [fill^="#000"], :not([fill])) {
  fill: var(--text-color);
}
svg :is([fill="white"], [fill^="#fff"]) {
  fill: var(--background-color);
}
</style>

</head>
<body class="xml2rfc">
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">Sigma Protocols</td>
<td class="right">April 2024</td>
</tr></thead>
<tfoot><tr>
<td class="left">Orrù &amp; Krenn</td>
<td class="center">Expires 19 October 2024</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">Network Working Group</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-orru-zkproof-sigma-latest</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2024-04-17" class="published">17 April 2024</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Informational</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2024-10-19">19 October 2024</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">M. Orrù</div>
<div class="org">CNRS</div>
</div>
<div class="author">
      <div class="author-name">S. Krenn</div>
<div class="org">AIT</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">Sigma Protocols</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document describes Sigma protocols, a secure, general-purpose non-interactive zero-knowledge proof of knowledge. Concretely, the scheme allows proving knowledge of the pre-representation of different group elements, without revealing any information about the undisclosed messages or the signature itself, while at the same time, guarantying soundness of the overall protocols.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<section class="note rfcEditorRemove" id="section-note.1">
      <h2 id="name-about-this-document">
<a href="#name-about-this-document" class="section-name selfRef">About This Document</a>
      </h2>
<p id="section-note.1-1">This note is to be removed before publishing as an RFC.<a href="#section-note.1-1" class="pilcrow">¶</a></p>
<p id="section-note.1-2">
        The latest revision of this draft can be found at <span><a href="https://mmaker.github.io/stdsigma/draft-orru-zkproof-sigma.html">https://mmaker.github.io/stdsigma/draft-orru-zkproof-sigma.html</a></span>.
        Status information for this document may be found at <span><a href="https://datatracker.ietf.org/doc/draft-orru-zkproof-sigma/">https://datatracker.ietf.org/doc/draft-orru-zkproof-sigma/</a></span>.<a href="#section-note.1-2" class="pilcrow">¶</a></p>
<p id="section-note.1-3">Source for this draft and an issue tracker can be found at
        <span><a href="https://github.com/mmaker/stdsigma">https://github.com/mmaker/stdsigma</a></span>.<a href="#section-note.1-3" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 19 October 2024.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2024 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="auto internal xref">1.1</a>.  <a href="#name-terminology" class="internal xref">Terminology</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="auto internal xref">1.2</a>.  <a href="#name-notation" class="internal xref">Notation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.3">
                <p id="section-toc.1-1.1.2.3.1" class="keepWithNext"><a href="#section-1.3" class="auto internal xref">1.3</a>.  <a href="#name-document-organization" class="internal xref">Document Organization</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.4">
                <p id="section-toc.1-1.1.2.4.1"><a href="#section-1.4" class="auto internal xref">1.4</a>.  <a href="#name-scope-of-this-document" class="internal xref">Scope of this document</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-sigma-protocols-definition" class="internal xref">Sigma protocols definition</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.1">
                <p id="section-toc.1-1.2.2.1.1"><a href="#section-2.1" class="auto internal xref">2.1</a>.  <a href="#name-overview" class="internal xref">Overview</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.2">
                <p id="section-toc.1-1.2.2.2.1"><a href="#section-2.2" class="auto internal xref">2.2</a>.  <a href="#name-an-abstract-class-for-gener" class="internal xref">An abstract class for generic Sigma protocols</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.3">
                <p id="section-toc.1-1.2.2.3.1"><a href="#section-2.3" class="auto internal xref">2.3</a>.  <a href="#name-the-fiat-shamir-transform" class="internal xref">The Fiat-Shamir Transform</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.3.2.1">
                    <p id="section-toc.1-1.2.2.3.2.1.1"><a href="#section-2.3.1" class="auto internal xref">2.3.1</a>.  <a href="#name-syntax" class="internal xref">Syntax</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.3.2.2">
                    <p id="section-toc.1-1.2.2.3.2.2.1"><a href="#section-2.3.2" class="auto internal xref">2.3.2</a>.  <a href="#name-hash-registry" class="internal xref">Hash Registry</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.3.2.3">
                    <p id="section-toc.1-1.2.2.3.2.3.1"><a href="#section-2.3.3" class="auto internal xref">2.3.3</a>.  <a href="#name-computing-the-challenge-and" class="internal xref">Computing the challenge and seeding the commitment</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.3.2.4">
                    <p id="section-toc.1-1.2.2.3.2.4.1"><a href="#section-2.3.4" class="auto internal xref">2.3.4</a>.  <a href="#name-non-interactive-proofs" class="internal xref">Non-interactive proofs</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.3.2.5">
                    <p id="section-toc.1-1.2.2.3.2.5.1"><a href="#section-2.3.5" class="auto internal xref">2.3.5</a>.  <a href="#name-batchable-proofs" class="internal xref">Batchable Proofs</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.3.2.6">
                    <p id="section-toc.1-1.2.2.3.2.6.1"><a href="#section-2.3.6" class="auto internal xref">2.3.6</a>.  <a href="#name-short-proofs" class="internal xref">Short Proofs</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.4">
                <p id="section-toc.1-1.2.2.4.1"><a href="#section-2.4" class="auto internal xref">2.4</a>.  <a href="#name-input-validation" class="internal xref">Input validation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.5">
                <p id="section-toc.1-1.2.2.5.1"><a href="#section-2.5" class="auto internal xref">2.5</a>.  <a href="#name-composition-of-sigma-protoc" class="internal xref">Composition of Sigma Protocols</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.5.2.1">
                    <p id="section-toc.1-1.2.2.5.2.1.1"><a href="#section-2.5.1" class="auto internal xref">2.5.1</a>.  <a href="#name-and-composition" class="internal xref">AND Composition</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.5.2.2">
                    <p id="section-toc.1-1.2.2.5.2.2.1"><a href="#section-2.5.2" class="auto internal xref">2.5.2</a>.  <a href="#name-or-composition" class="internal xref">OR Composition</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-sigma-protocols-on-elliptic" class="internal xref">Sigma protocols on elliptic curves</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="auto internal xref">3.1</a>.  <a href="#name-ciphersuite-registry" class="internal xref">Ciphersuite Registry</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="auto internal xref">3.2</a>.  <a href="#name-basic-sigma-protocols-in-pr" class="internal xref">Basic Sigma Protocols in prime-order groups</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="auto internal xref">3.3</a>.  <a href="#name-advanced-proving-linear-rel" class="internal xref">Advanced: proving linear relations</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.4">
                <p id="section-toc.1-1.3.2.4.1"><a href="#section-3.4" class="auto internal xref">3.4</a>.  <a href="#name-examples" class="internal xref">Examples</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.4.2.1">
                    <p id="section-toc.1-1.3.2.4.2.1.1"><a href="#section-3.4.1" class="auto internal xref">3.4.1</a>.  <a href="#name-schnorr-signatures" class="internal xref">Schnorr signatures</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.4.2.2">
                    <p id="section-toc.1-1.3.2.4.2.2.1"><a href="#section-3.4.2" class="auto internal xref">3.4.2</a>.  <a href="#name-discrete-logarithm-equality" class="internal xref">Discrete logarithm equality</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.4.2.3">
                    <p id="section-toc.1-1.3.2.4.2.3.1"><a href="#section-3.4.3" class="auto internal xref">3.4.3</a>.  <a href="#name-diffie-hellman" class="internal xref">Diffie-Hellman</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.4.2.4">
                    <p id="section-toc.1-1.3.2.4.2.4.1"><a href="#section-3.4.4" class="auto internal xref">3.4.4</a>.  <a href="#name-representation" class="internal xref">Representation</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.5">
                <p id="section-toc.1-1.3.2.5.1"><a href="#section-3.5" class="auto internal xref">3.5</a>.  <a href="#name-batch-verification" class="internal xref">Batch verification</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-encoding-the-statement" class="internal xref">Encoding the statement</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-additional-proof-types" class="internal xref">Additional proof types</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref"></a><a href="#name-acknowledgments" class="internal xref">Acknowledgments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#appendix-A" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">Zero-knowledge proofs of knowledge allow a prover to convince a verifier that they know a secret piece of information, without revealing anything except that the claim itself already reveals. Many practically relevant proof goals can be realized using so-called Sigma protocols. Introduced by
Schnorr over 30 years ago, they play an essential
component in the building of a number of cryptographic constructions,
such as anonymous credentials, password-authenticated
key exchange, signatures, ring
signatures, blind signatures, multi
signatures, threshold signatures and
more. This spec provides guidelines for correctly implementing
Sigma protocols.<a href="#section-1-1" class="pilcrow">¶</a></p>
<div id="terminology">
<section id="section-1.1">
        <h3 id="name-terminology">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-terminology" class="section-name selfRef">Terminology</a>
        </h3>
<p id="section-1.1-1">Given sets $\mathcal{Y}$ and $\mathcal{W}$, a <em>binary relation</em>
${\mathsf{R}}\subseteq \mathcal{Y} \times \mathcal{W}$
associates elements from $\mathcal{Y}$ with elements from $\mathcal{W}$.
For $(Y,w)\in{\mathsf{R}}$, we refer to $Y$ as a
<em>statement</em>, and to $w$ as a <em>witness</em> (for $Y$). The statement is
public information shared between prover and verifier. The witness is
secret information solely known by the prover. Note there may be
multiple witnesses for a given $Y$.<a href="#section-1.1-1" class="pilcrow">¶</a></p>
<p id="section-1.1-2">::: example
Discrete logarithm equality R_DLEQ Let $\GG$ be a cyclic group of prime
order $p$, and let $G$ and $H$ be generators of $\GG$. Then the
following relation ${\mathsf{R}_{\operatorname{dleq}}}$ contains as
statements all pairs of elements having the same discrete logarithm with
respect to $G$ and $H$, with the corresponding witness being their
discrete logarithm:
<span class="contact-name">{\mathsf{R}_{øperatorname{dleq}}} = \set{łeft((Y_1,Y_2),w\right) ∈ \GG^2× \FF_p~:~Y_1=wG ~łand~ Y_2=wH} .</span>
:::<a href="#section-1.1-2" class="pilcrow">¶</a></p>
<p id="section-1.1-3">::: example
RepresentationR_REP Let $\GG$ be a cyclic group of prime order $p$, and
let $G$ and $H$ be generators of $\GG$. Then the following relation
${\mathsf{R}_{\operatorname{rep}}}$ contains as statements all valid
Perdersen commitments, with the corresponding witnesses being their
openings:
<span class="contact-name">{\mathsf{R}_{øperatorname{rep}}} = \set{łeft(Y,(w_1,w_2)\right)∈ \GG × \FF_p^2~:~Y=w_1G + w_2H} .</span>
Note that in this case, each statement has $p$ valid witnesses.
:::<a href="#section-1.1-3" class="pilcrow">¶</a></p>
<p id="section-1.1-4">In a zero-knowledge proof, the <em>witness</em> is secret information, while
the <em>statement</em> is public. A <em>proof</em> is a sequence of bytes
attesting that a witness is in some relation with the statement.<a href="#section-1.1-4" class="pilcrow">¶</a></p>
<p id="section-1.1-5">Proofs described in this spec are zero-knowledge and sound. Zero
knowledge means that the protocol does not leak any information about
the prover's witness beyond what the attacker may infer from the proven
statement or from other sources [@zkproof-reference 1.6.4]. Soundness
means that it is not possible to make the verifier accept for statements
for which no valid witness exists [@zkproof-reference 1.6.2].<a href="#section-1.1-5" class="pilcrow">¶</a></p>
<p id="section-1.1-6">In particular we will focus on non-malleable extractable proofs, that
is, proofs where the the witness does not only exist but is also
precisely known by the prover. These protocols are also known as proofs
of knowledge [@STOC:GolMicRac85; @STOC:FeiFiaSha87; @C:BelGol92] and are
said to satisfy <em>knowledge soundness</em> [@damgard04]. Non-malleability
means that, in addition, the proof is secure against man-in-the middle
attacks, and attackers cannot produce a new valid proof by tampering
another valid proof.<a href="#section-1.1-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec_notation">
<section id="section-1.2">
        <h3 id="name-notation">
<a href="#section-1.2" class="section-number selfRef">1.2. </a><a href="#name-notation" class="section-name selfRef">Notation</a>
        </h3>
<p id="section-1.2-1">Additional notation will be introduced when describing specific
algebraic objects.<a href="#section-1.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="document-organization">
<section id="section-1.3">
        <h3 id="name-document-organization">
<a href="#section-1.3" class="section-number selfRef">1.3. </a><a href="#name-document-organization" class="section-name selfRef">Document Organization</a>
      </h3>
</section>
</div>
<div id="scope-of-this-document">
<section id="section-1.4">
        <h3 id="name-scope-of-this-document">
<a href="#section-1.4" class="section-number selfRef">1.4. </a><a href="#name-scope-of-this-document" class="section-name selfRef">Scope of this document</a>
        </h3>
<p id="section-1.4-1">This document provides guidelines for secure implementations of
Sigma protocols and is addressed to applied cryptographers and
cryptographic engineers that are looking to implement a generic
Sigma protocol or provide an ad-hoc instantiation as part of a larger
protocols.<a href="#section-1.4-1" class="pilcrow">¶</a></p>
<p id="section-1.4-2">We consider the problem of having a high-quality entropy source
well-suited for cryptographic purposes outside of the scope of this
document. We will not talk about implementation of cryptographic
primitives such as hash functions, or elliptic-curve algebra, but we
will provide references for where to find them. We won't provide any
guidance for securely storing secrets or producing constant-time code.<a href="#section-1.4-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="sigma-protocols-definition">
<section id="section-2">
      <h2 id="name-sigma-protocols-definition">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-sigma-protocols-definition" class="section-name selfRef">Sigma protocols definition</a>
      </h2>
<p id="section-2-1">In the following, we describe a generic interface for
Sigma protocols. Such protocols can be used to prove that, for some
binary relation ${\mathsf{R}}$ and a public value
$Y$, a witness $w$ such that $(Y,w)\in{\mathsf{R}}$
is known. Basic statements include proofs of knowledge of a secret key,
openings of commitments, and more in general of representations. The
type of these elements depends on the specific relation being
implemented.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">An important property of Sigma protocols is that they are composable:
it is possible to prove conjunction and disjunctions of statements in
zero-knowledge. Composition of Sigma protocols is dealt separately; for an in-depth discussion of the
underlying theory we refer to Cramer [@cramer97].<a href="#section-2-2" class="pilcrow">¶</a></p>
<div id="overview">
<section id="section-2.1">
        <h3 id="name-overview">
<a href="#section-2.1" class="section-number selfRef">2.1. </a><a href="#name-overview" class="section-name selfRef">Overview</a>
        </h3>
<p id="section-2.1-1">Any Sigma protocol is structured as follows:<a href="#section-2.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2.1-2.1">
            <p id="section-2.1-2.1.1">the prover computes a fresh <strong>commitment</strong>, denoted $T$. This
element is sometimes also called <em>nonce</em>.<a href="#section-2.1-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-2.1-2.2">
            <p id="section-2.1-2.2.1">the prover computes, using the so-called Fiat-Shamir transform,
a random <strong>challenge</strong>, denoted $c$.<a href="#section-2.1-2.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-2.1-2.3">
            <p id="section-2.1-2.3.1">the prover computes a <strong>response</strong>, denoted $s$, that depends on the
commitment and the challenge.<a href="#section-2.1-2.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-2.1-3">The final proof is constituted of the three-elements above $(T, c, s)$,
and is also referred to as the <strong>transcript</strong>.<a href="#section-2.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="an-abstract-class-for-generic-sigma-protocols">
<section id="section-2.2">
        <h3 id="name-an-abstract-class-for-gener">
<a href="#section-2.2" class="section-number selfRef">2.2. </a><a href="#name-an-abstract-class-for-gener" class="section-name selfRef">An abstract class for generic Sigma protocols</a>
        </h3>
<p id="section-2.2-1">We define a template class for Sigma protocols denoted
<code>SigmaProtocol</code>. This is the basic interface that will be
implemented remainder of this document. The methods composing
<code>SigmaProtocol</code> should be considered <em>private</em> and <em>should not</em>
be exposed externally. The public API is described later. Instances
are created via the <code>new</code> function, which is a class method,
while all other functions act on a particular instance. A
<code>SigmaProtocol</code> consists of the following methods:<a href="#section-2.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2.2-2.1">
            <p id="section-2.2-2.1.1">$<code>SigmaProtocol</code>.<code>new</code>(<code>ctx</code>, Y)$, denoting the
initialization function. This function takes as input a label
identifying local context information <code>ctx</code> (such as:
session identifiers, to avoid replay attacks; protocol metadata, to
avoid hijacking; optionally, a timestamp and some pre-shared
randomness, to guarantee freshness of the proof) and a statement
$Y$, the public information shared between prover and verifier. This
function <em>should</em> pre-compute parts of the statement, or initialize
the state of the hash function.<a href="#section-2.2-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-2.2-2.2">
            <p id="section-2.2-2.2.1">$(T, <code>pstate</code>)\gets <code>SigmaProtocol</code>.<code>prover_commit</code>(w)$,
denoting the <em>commitment phase</em>, that is, the computation of the
first message sent by the prover in a Sigma protocol. This method
outputs a new commitment together with its associated prover state,
depending on the witness known to the prover and the statement to be
proven. This step generally requires access to a high-quality
entropy source. Leakage of even just of a few bits of the nonce
could allow for the complete recovery of the
witness [@lattice-attack; @bleichenbacher; @CCS:ANTTY20]. The value
$T$ is meant to be shared, while <code>pstate</code> must be kept
secret.<a href="#section-2.2-2.2.1" class="pilcrow">¶</a></p>
<p id="section-2.2-2.2.2">
In particular, we assume that there exists a function
$<code>Serialize</code>(T)$ that serializes the commitment $T$ and that
its size is fixed and implicitly determined by the statement $Y$.<a href="#section-2.2-2.2.2" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-2.2-2.3">
            <p id="section-2.2-2.3.1">$s\gets <code>SigmaProtocol</code>.<code>prover_response</code>(<code>pstate</code>, c)$,
denoting the <em>response phase</em>, that is, the computation of the
second message sent by the prover, depending on the witness, the
statement, the challenge received from the verifier, and the
internal state generated by <code>prover_commit</code>. The value $s$
is meant to be shared.<a href="#section-2.2-2.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-2.2-2.4">
            <p id="section-2.2-2.4.1">$<code>yesno</code> \gets <code>SigmaProtocol</code>.<code>verifier</code>(T, c, s)$,
denoting the <em>verifier algorithm</em>. This method checks that the
<em>protocol transcript</em> is valid for the given statement. The verifier
algorithm outputs nothing if verification succeeds, or an error if
verification fails.<a href="#section-2.2-2.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-2.2-2.5">
            <p id="section-2.2-2.5.1">$<code>label</code> \gets<code>SigmaProtocol</code>.<code>label</code>()$,
returning a string of $\ensuremath{\SI{32}{\byte}}$ uniquely
identifying the relation being proven. Implementing this function
correctly is vital for security, and it must include all data
available in the statement, as well as the parameters and the
relation being proven. The label will be used for computing the
challenge in the Fiat-Shamir transform.
Precise indications on how to implement this function will be given
in the following sections.<a href="#section-2.2-2.5.1" class="pilcrow">¶</a></p>
<p id="section-2.2-2.5.2">
If the label is <em>not</em> tied to the relation, then it may be possible
to produce another proof for a different relation without knowing
its witness. Similarly, if the statement is not tied to the label,
then it may be possible to produce proofs for another statement
whose witness is related to the original proof.<a href="#section-2.2-2.5.2" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-2.2-3">The final two algorithms describe the <em>zero-knowledge simulator</em>. The
simulator is primarily an efficient algorithm for proving zero-knowledge
in a theoretical construction [@becafi19], but it is also needed for
verifying short proofs and for or-composition, where a witness is not known and thus has to
be simulated. We have:<a href="#section-2.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2.2-4.1">
            <p id="section-2.2-4.1.1">$s\gets <code>SigmaProtocol</code>.<code>simulate_response</code>()$,
denoting the first stage of the <em>simulator</em>. It is an algorithm
drawing a random response that follows the same output distribution
of the algorithm <code>prover_response</code>.<a href="#section-2.2-4.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-2.2-4.2">
            <p id="section-2.2-4.2.1">$T\gets <code>SigmaProtocol</code>.<code>simulate_commitment</code>(c, s)$,
denoting the second stage of the <em>simulator</em>, returning a commitment
that follows the same output distribution of the algorithm
<code>prover_commit</code>.<a href="#section-2.2-4.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="sec_fs">
<section id="section-2.3">
        <h3 id="name-the-fiat-shamir-transform">
<a href="#section-2.3" class="section-number selfRef">2.3. </a><a href="#name-the-fiat-shamir-transform" class="section-name selfRef">The Fiat-Shamir Transform</a>
        </h3>
<p id="section-2.3-1">The interactive versions of the Sigma protocols presented in this
document are not fit for practical applications, due to subtle yet
impactful details in their security guarantees. In practice, public-coin
protocols such as Sigma protocols can be converted into
non-interactive ones through the Fiat and Shamir heuristic [@C:FiaSha86]
and subsequent work, e.g., by Bernhard, Pereira and
Warinschi [@AC:BerPerWar12].<a href="#section-2.3-1" class="pilcrow">¶</a></p>
<p id="section-2.3-2">The underlying idea is to replace the verifier with a cryptographically
secure hash function, hashing the context from the protocol and the
previous message sent by the prover.<a href="#section-2.3-2" class="pilcrow">¶</a></p>
<p id="section-2.3-3">::: warning
Interactive Sigma protocols Sigma protocols illustrated in this
spec <strong>must not</strong> be used interactively.
:::<a href="#section-2.3-3" class="pilcrow">¶</a></p>
<div id="syntax">
<section id="section-2.3.1">
          <h4 id="name-syntax">
<a href="#section-2.3.1" class="section-number selfRef">2.3.1. </a><a href="#name-syntax" class="section-name selfRef">Syntax</a>
          </h4>
<p id="section-2.3.1-1">When using a hash function we will employ comma-separated values to
indicate values that are concatenated. To mitigate attacks and allow for
state cloning, we also separate values with semi-colons to indicate that
they must appear in a subsequent block and that the previous is padded
with zeros. For instance, with the writing
$\hash(a \,\textbf{,}~b \,\mathbf{\mid}~c)$ we denote the hashing of $a$
concatenated to $b$, then padded with the null byte until to reach the
closest multiple of <code>BLOCK_LEN</code> bytes added, then and
concatenate the resulting bit string to $c$.<a href="#section-2.3.1-1" class="pilcrow">¶</a></p>
<div id="constants">
<section id="section-2.3.1.1">
            <h5 id="name-constants">
<a href="#section-2.3.1.1" class="section-number selfRef">2.3.1.1. </a><a href="#name-constants" class="section-name selfRef">Constants.</a>
            </h5>
<p id="section-2.3.1.1-1">Different hash functions may rely on different constants. We define some
of the parameters associated to the hash function that will be used
throughout this spec.<a href="#section-2.3.1.1-1" class="pilcrow">¶</a></p>
<p id="section-2.3.1.1-2">::: center
         Const name        Notes
  ------------------------ -------------------------------------------------------------------------------------------------------------
     <code>DOMSEP}$     Domain separator for this standard. Fixed to $\texttt{\textquotesingle{}zkpstd/sigma/0.1\textquotesingle</code>.
   <code>BLOCK_LEN</code>   Length of a hash block
   <code>DIGEST_LEN</code>  Digest length
:::<a href="#section-2.3.1.1-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="sec_hash-registry">
<section id="section-2.3.2">
          <h4 id="name-hash-registry">
<a href="#section-2.3.2" class="section-number selfRef">2.3.2. </a><a href="#name-hash-registry" class="section-name selfRef">Hash Registry</a>
          </h4>
<p id="section-2.3.2-1">This is the set of all supported hash functions. They take an arbitrary
length sequence of bytes as input, and output
$\ensuremath{\SI{32}{\byte}}$ of entropy.<a href="#section-2.3.2-1" class="pilcrow">¶</a></p>
<p id="section-2.3.2-2">::: center
  Hash       Source           <code>BLOCK_LEN}$    $\texttt{DIGEST_LEN</code>
  ---------- ---------------- ----------------------- ------------------------ --
  blake2b    [@ACNS:ANWW13]   128                                64
  sha3-256   [@EC:BDPA13]     136                                32
:::<a href="#section-2.3.2-2" class="pilcrow">¶</a></p>
<p id="section-2.3.2-3">Supported hash functions must all have $<code>BLOCK_LEN</code>\geq 32$. We
define labels and constant strings so that their length is always at
most $\ensuremath{\SI{32}{\byte}}$. If $<code>DIGEST_LEN</code>\ge 32$, we
implicitly assume that the implementation considers only the least
significant bytes and discards the remainder of the hash output when
exactly $\ensuremath{\SI{32}{\byte}}$ bytes are needed.<a href="#section-2.3.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec_fs-challenge">
<section id="section-2.3.3">
          <h4 id="name-computing-the-challenge-and">
<a href="#section-2.3.3" class="section-number selfRef">2.3.3. </a><a href="#name-computing-the-challenge-and" class="section-name selfRef">Computing the challenge and seeding the commitment</a>
          </h4>
<p id="section-2.3.3-1">Relying on a hash function allows us to both compute the challenge and
generate the commitment securely. We define the following auxiliary
variables that may be pre-computed during the call of
$<code>SigmaProtocol</code>.<code>new</code>(<code>ctx</code>, Y)$. All variables
will have fixed length <code>DIGEST_LEN</code> so to avoid
canonicalization attacks.<a href="#section-2.3.3-1" class="pilcrow">¶</a></p>
<div id="seeding-the-commitment">
<section id="section-2.3.3.1">
            <h5 id="name-seeding-the-commitment">
<a href="#section-2.3.3.1" class="section-number selfRef">2.3.3.1. </a><a href="#name-seeding-the-commitment" class="section-name selfRef">Seeding the commitment.</a>
            </h5>
<p id="section-2.3.3.1-1">The method $<code>SigmaProtocol</code>.<code>prover_commit</code>()$ is a
randomized function that generates a random element, unique per each
execution. The commitment <em>should</em> be seeded as follows:<a href="#section-2.3.3.1-1" class="pilcrow">¶</a></p>
<p id="section-2.3.3.1-2">If the output length <code>DIGEST_LEN</code> of the
hash function is not sufficient to provide enough entropy for the
commitment, the seed may be expanded with a PRNG to provide the quantity
of random bytes desired.<a href="#section-2.3.3.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="computing-the-challenge">
<section id="section-2.3.3.2">
            <h5 id="name-computing-the-challenge">
<a href="#section-2.3.3.2" class="section-number selfRef">2.3.3.2. </a><a href="#name-computing-the-challenge" class="section-name selfRef">Computing the challenge.</a>
            </h5>
<p id="section-2.3.3.2-1">The method $<code>SigmaProtocol</code>.<code>challenge</code>(\mu, T)$ is
implemented as follows in order to produce a random challenge.<a href="#section-2.3.3.2-1" class="pilcrow">¶</a></p>
<p id="section-2.3.3.2-2">If no message is being set, i.e. if $\mu= \mathsf{None}$, then the
implementation may decide to skip the computation of $\text{hm}$ and
consider it empty. This method is fixed for all implementations of
<code>SigmaProtocol</code>. Note that the state of the hash function is
partially shared between the commitment seed inputs and the challenge
computation. Implementors may choose to store the partial hash state
before generating the commitment, and reuse it when computing the
challenge.<a href="#section-2.3.3.2-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="non-interactive-proofs">
<section id="section-2.3.4">
          <h4 id="name-non-interactive-proofs">
<a href="#section-2.3.4" class="section-number selfRef">2.3.4. </a><a href="#name-non-interactive-proofs" class="section-name selfRef">Non-interactive proofs</a>
          </h4>
<p id="section-2.3.4-1">We define two <em>public methods</em> for generating proofs, meant to be
exposed externally: <code>short_proof</code>, and
<code>batchable_proof</code>. Since the challenge is computed
deterministically from the commitment and the statement, it is not
necessary to include the full transcript in a proof, as it can be
deduced in the verification phase.<a href="#section-2.3.4-1" class="pilcrow">¶</a></p>
<p id="section-2.3.4-2">Short proofs are the most efficient if the protocol contains at least an
<em>AND</em> composition, and the gain in size
is measured as $|\mathbf T| - <code>DIGEST_LEN</code>$. (Note: the length
of the commitment is the length of the statement.) Batchable proofs are
the canonical forms of proofs. Provers in the batchable form may raise
an exception if the statement is not valid. Proofs are seen as
fixed-length bit strings, whose exact length can be inferred from the
statement during initialization of the Sigma protocol.<a href="#section-2.3.4-2" class="pilcrow">¶</a></p>
<p id="section-2.3.4-3">::: remark
Witness validation In the following we assume correctness of the witness
$w$ for the given statement $Y$. This can be ensured, e.g., by a
higher-level application, or by running
$<code>SigmaProtocol</code>.<code>verifier</code>(T, c, s)$ before sending the
resulting proof.
:::<a href="#section-2.3.4-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="batchable-proofs">
<section id="section-2.3.5">
          <h4 id="name-batchable-proofs">
<a href="#section-2.3.5" class="section-number selfRef">2.3.5. </a><a href="#name-batchable-proofs" class="section-name selfRef">Batchable Proofs</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="section-2.3.5-1">
            <dt id="section-2.3.5-1.1">Prover algorithm.</dt>
            <dd style="margin-left: 1.5em" id="section-2.3.5-1.2">
              <p id="section-2.3.5-1.2.1">The public function
$<code>SigmaProtocol</code>.<code>batchable_proof</code>( w, \mu)$
computes:<a href="#section-2.3.5-1.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.3.5-1.2.2">
<li id="section-2.3.5-1.2.2.1">
                  <p id="section-2.3.5-1.2.2.1.1">$(T,<code>pstate</code>)\gets<code>SigmaProtocol</code>.<code>prover_commit</code>( w)$.<a href="#section-2.3.5-1.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.3.5-1.2.2.2">
                  <p id="section-2.3.5-1.2.2.2.1">$c \gets <code>SigmaProtocol</code>.<code>challenge</code>(\mu,T)$<a href="#section-2.3.5-1.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.3.5-1.2.2.3">
                  <p id="section-2.3.5-1.2.2.3.1">$s\gets<code>SigmaProtocol</code>.<code>prover_response</code>(<code>pstate</code>,  c)$.
Return $<code>Serialize</code>(T)$ concatenated to
$<code>Serialize</code>(\mathbf s)$<a href="#section-2.3.5-1.2.2.3.1" class="pilcrow">¶</a></p>
</li>
              </ol>
<p id="section-2.3.5-1.2.3">The challenge $c$ is not provided within a batchable proof since it
can be re-computed from the commitment.<a href="#section-2.3.5-1.2.3" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="section-2.3.5-1.3">Verifier algorithm.</dt>
            <dd style="margin-left: 1.5em" id="section-2.3.5-1.4">
              <p id="section-2.3.5-1.4.1">The verifier's algorithm
$<code>SigmaProtocol</code>.<code>batchable_verify</code>(\pi, \mu)$ works
as follows:<a href="#section-2.3.5-1.4.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.3.5-1.4.2">
<li id="section-2.3.5-1.4.2.1">
                  <p id="section-2.3.5-1.4.2.1.1">$(T,s) \coloneqq<code>Deserialize</code>(\pi)$<a href="#section-2.3.5-1.4.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.3.5-1.4.2.2">
                  <p id="section-2.3.5-1.4.2.2.1">$c \gets <code>SigmaProtocol</code>.<code>challenge</code>(\mu, T)$<a href="#section-2.3.5-1.4.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.3.5-1.4.2.3">
                  <p id="section-2.3.5-1.4.2.3.1">Return whatever
$<code>SigmaProtocol</code>.<code>verifier</code>(T,c, s)$ returns.<a href="#section-2.3.5-1.4.2.3.1" class="pilcrow">¶</a></p>
</li>
              </ol>
<p id="section-2.3.5-1.4.3">::: warning
Input validation The case of batched verification must include an
input validation sub-routine that asserts the statement and
commitments are in question. In the case of elliptic curves, this boils down to point
validation. Failure to properly check that a commitment is in the
group could lead to subgroup attacks [@EC:VanWie96; @C:LimLee97] or
invalid curve attacks [@C:BieMeyMul00; @RSA:BBPV12].
:::<a href="#section-2.3.5-1.4.3" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec_shortproof">
<section id="section-2.3.6">
          <h4 id="name-short-proofs">
<a href="#section-2.3.6" class="section-number selfRef">2.3.6. </a><a href="#name-short-proofs" class="section-name selfRef">Short Proofs</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="section-2.3.6-1">
            <dt id="section-2.3.6-1.1">Prover algorithm.</dt>
            <dd style="margin-left: 1.5em" id="section-2.3.6-1.2">
              <p id="section-2.3.6-1.2.1">A new proof $<code>SigmaProtocol</code>.<code>short_proof</code>(w, \mu)$
is built as follows:<a href="#section-2.3.6-1.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.3.6-1.2.2">
<li id="section-2.3.6-1.2.2.1">
                  <p id="section-2.3.6-1.2.2.1.1">$(T,<code>pstate</code>)\gets<code>SigmaProtocol</code>.<code>prover_commit</code>(w)$.<a href="#section-2.3.6-1.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.3.6-1.2.2.2">
                  <p id="section-2.3.6-1.2.2.2.1">$c \gets <code>SigmaProtocol</code>.<code>challenge</code>(\mu,  T)$<a href="#section-2.3.6-1.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.3.6-1.2.2.3">
                  <p id="section-2.3.6-1.2.2.3.1">$\mathbf s\gets<code>SigmaProtocol</code>.<code>prover_response</code>(<code>pstate</code>,c)$.<a href="#section-2.3.6-1.2.2.3.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.3.6-1.2.2.4">
                  <p id="section-2.3.6-1.2.2.4.1">Return $<code>Serialize</code>(c)$ concatenated to
$<code>Serialize</code>(s)$.<a href="#section-2.3.6-1.2.2.4.1" class="pilcrow">¶</a></p>
</li>
              </ol>
<p id="section-2.3.6-1.2.3">The commitment $T$ is not provided within a short proof since it can
be calculated again.<a href="#section-2.3.6-1.2.3" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="section-2.3.6-1.3">Verifier algorithm.</dt>
            <dd style="margin-left: 1.5em" id="section-2.3.6-1.4">
              <p id="section-2.3.6-1.4.1">The verifier's algorithm
$<code>SigmaProtocol</code>.<code>short_verify</code>(\pi, \mu)$ works as
follows:<a href="#section-2.3.6-1.4.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.3.6-1.4.2">
<li id="section-2.3.6-1.4.2.1">
                  <p id="section-2.3.6-1.4.2.1.1">$(c, s) \coloneqq<code>Deserialize</code>(\pi)$<a href="#section-2.3.6-1.4.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.3.6-1.4.2.2">
                  <p id="section-2.3.6-1.4.2.2.1">$T\gets <code>SigmaProtocol</code>.<code>simulate_commitment</code>(c, s)\,.$<a href="#section-2.3.6-1.4.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.3.6-1.4.2.3">
                  <p id="section-2.3.6-1.4.2.3.1">$c^* \gets <code>SigmaProtocol</code>.<code>challenge</code>(\mu, T)$<a href="#section-2.3.6-1.4.2.3.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.3.6-1.4.2.4">
                  <p id="section-2.3.6-1.4.2.4.1">Check whether $c=c^*$. Output $\pctrue$ if this is the case, and
$\pcfalse$ otherwise.<a href="#section-2.3.6-1.4.2.4.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-2.3.6-2">If input parsing fails, an exception should be raised. If verification
fails, an exception should be raised. Otherwise, the verifier outputs
$\pctrue$. Optionally, the implementation can choose to return the
parsed statement.<a href="#section-2.3.6-2" class="pilcrow">¶</a></p>
<p id="section-2.3.6-3">::: remark
Availability of the short form While the short form as described here is
applicable to all Sigma protocols currently covered by this document,
it cannot be used for protocols where $T$ is not uniquely determined by
$c$ and $s$, as is the case, e.g., for ZKBoo [@USENIX:GiaMadOrl16],
one-out-of-many proofs [@EC:GroKoh15], or protocols, where a randomized
signature is sent and proven correct subsequently, e.g.,
[@RSA:PoiSan16; @AC:CamChaShe08].<a href="#section-2.3.6-3" class="pilcrow">¶</a></p>
<p id="section-2.3.6-4">A trade-off is presented, e.g., by Bobolz et al. [@EPRINT:BEHF21],
requiring an additional algorithm to shorten a full transcript to a
compressed form which still allows for unique reconstruction of the
transcript.
:::<a href="#section-2.3.6-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="input-validation">
<section id="section-2.4">
        <h3 id="name-input-validation">
<a href="#section-2.4" class="section-number selfRef">2.4. </a><a href="#name-input-validation" class="section-name selfRef">Input validation</a>
      </h3>
</section>
</div>
<div id="sec_composition">
<section id="section-2.5">
        <h3 id="name-composition-of-sigma-protoc">
<a href="#section-2.5" class="section-number selfRef">2.5. </a><a href="#name-composition-of-sigma-protoc" class="section-name selfRef">Composition of Sigma Protocols</a>
        </h3>
<p id="section-2.5-1">[]{#sec:or-comp label="sec:or-comp"} []{#sec:and-comp
label="sec:and-comp"} Sigma protocols can be composed to prove
knowledge of multiple independent witnesses (<em>AND composition</em>), and for
proving knowledge for one out of a set of witnesses (<em>OR composition</em>).
An object <code>SigmaProtocol</code> can be seen as a recursive
enumeration<a href="#section-2.5-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-2.5-2">
<pre>
    enum SigmaProtocol {
      AndComposition {left: SigmaProtocol, right: SigmaProtocol},
      OrComposition  {left: SigmaProtocol, right: SigmaProtocol},
      [...]
    }
</pre><a href="#section-2.5-2" class="pilcrow">¶</a>
</div>
<p id="section-2.5-3">whose instances expose the methods described above. The dots <code>[...]</code>
denote (optional) Sigma protocols instantiations that will be covered later.
Without loss of generality, the techniques
presented in the following focus on the composition of two protocols.
Composition of multiple protocols (e.g., proving knowledge of a witness
for one out of many statements) can be achieved by recursively applying
composition of two protocols.<a href="#section-2.5-3" class="pilcrow">¶</a></p>
<div id="and-composition">
<section id="section-2.5.1">
          <h4 id="name-and-composition">
<a href="#section-2.5.1" class="section-number selfRef">2.5.1. </a><a href="#name-and-composition" class="section-name selfRef">AND Composition</a>
          </h4>
<p id="section-2.5.1-1">In this section we show how to construct a Sigma protocol proving
knowledge of multiple independent witnesses, e.g., knowledge of multiple
secret keys, or openings to multiple commitments. That is, a
Sigma protocol for the following relation:
<span class="contact-name">{\mathsf{R}_{øperatorname{and}}} = \set{     ((Y_0,Y_1),(w_0,w_1) : (Y_0,w_0)∈ {\mathsf{R}}_0 ~łand~ (Y_1,w_1)∈{\mathsf{R}}_1}</span>
For the rest of this section, the witness $w$ for the Sigma protocol
will now be a pair $(w_0, w_1)$ of witnesses, and the associated
statement $Y$ will be a pair $(Y_0, Y_1)$ of statements, where $w_0$ is
the witness for the statement $Y_0$, and $w_1$ is the witness for $Y_1$.<a href="#section-2.5.1-1" class="pilcrow">¶</a></p>
<p id="section-2.5.1-2">Intuitively, the AND composition simply runs the instances of the
different protocols to be composed in parallel, using the same challenge
$c$ for both instances. The verifier will then accept the protocol run,
if and only if all instances of the partial protocols output $\pctrue$.<a href="#section-2.5.1-2" class="pilcrow">¶</a></p>
<p id="section-2.5.1-3">The resulting Sigma protocol is specified by the following
algorithms:<a href="#section-2.5.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2.5.1-4.1">
              <p id="section-2.5.1-4.1.1">$<code>AndComposition</code>.<code>new</code>(<code>ctx</code>, <code>left</code>, <code>right</code>)$:
internally store <code>left}$ and $\texttt{right</code>.<a href="#section-2.5.1-4.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-2.5.1-4.2">
              <p id="section-2.5.1-4.2.1">$(\mathbf T, <code>pstate</code>)\gets <code>AndComposition</code>.<code>prover_commit</code>(\mathbf w)$<a href="#section-2.5.1-4.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.5.1-4.2.2">
<li id="section-2.5.1-4.2.2.1">
                  <p id="section-2.5.1-4.2.2.1.1">$(w_0,w_1)\coloneqq\mathbf w$<a href="#section-2.5.1-4.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.1-4.2.2.2">
                  <p id="section-2.5.1-4.2.2.2.1">$(T_0,<code>pstate</code>_0)\gets<code>left</code>.<code>prover_commit</code>(w_0)$<a href="#section-2.5.1-4.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.1-4.2.2.3">
                  <p id="section-2.5.1-4.2.2.3.1">$(T_1,<code>pstate</code>_1)\gets<code>right</code>.<code>prover_commit</code>(w_1)$<a href="#section-2.5.1-4.2.2.3.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.1-4.2.2.4">
                  <p id="section-2.5.1-4.2.2.4.1">Return
$(\mathbf T,<code>pstate</code>) \coloneqq((T_0,  T_1),(<code>pstate</code>_0,<code>pstate</code>_1))$<a href="#section-2.5.1-4.2.2.4.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li class="normal" id="section-2.5.1-4.3">
              <p id="section-2.5.1-4.3.1">$\mathbf s\gets <code>AndComposition</code>.<code>prover_response</code>(<code>pstate</code>, c)$<a href="#section-2.5.1-4.3.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.5.1-4.3.2">
<li id="section-2.5.1-4.3.2.1">
                  <p id="section-2.5.1-4.3.2.1.1">$(<code>pstate</code>_0,<code>pstate</code>_1)\coloneqq<code>pstate</code>$<a href="#section-2.5.1-4.3.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.1-4.3.2.2">
                  <p id="section-2.5.1-4.3.2.2.1">$s_0\gets<code>left</code>.<code>prover_response</code>(<code>pstate</code>_0, c)$<a href="#section-2.5.1-4.3.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.1-4.3.2.3">
                  <p id="section-2.5.1-4.3.2.3.1">$s_1\gets<code>right</code>.<code>prover_response</code>(<code>pstate</code>_1, c)$<a href="#section-2.5.1-4.3.2.3.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.1-4.3.2.4">
                  <p id="section-2.5.1-4.3.2.4.1">Return $\mathbf s\coloneqq(s_0,s_1)$<a href="#section-2.5.1-4.3.2.4.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li class="normal" id="section-2.5.1-4.4">
              <p id="section-2.5.1-4.4.1">$<code>AndComposition</code>.<code>verifier</code>(\mathbf T, c, \mathbf s)$<a href="#section-2.5.1-4.4.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.5.1-4.4.2">
<li id="section-2.5.1-4.4.2.1">
                  <p id="section-2.5.1-4.4.2.1.1">$(s_0,s_1)\coloneqq\mathbf s$.<a href="#section-2.5.1-4.4.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.1-4.4.2.2">
                  <p id="section-2.5.1-4.4.2.2.1">Return $\pctrue$ if both
$<code>left</code>.<code>verifier</code>(T_0,c, s_0)$ and
$<code>right</code>.<code>verifier</code>(T_1,c, s_1)$ return $\pctrue$.
Otherwise, return $\pcfalse$.<a href="#section-2.5.1-4.4.2.2.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li class="normal" id="section-2.5.1-4.5">
              <p id="section-2.5.1-4.5.1">$<code>AndComposition</code>.<code>label</code>()$ is computed as:
<span class="contact-name">ℎash(\texttt{\textquotesingle{}and−composition\textquotesingle} \mathbf{∣}~`left`.`label`()  \textbf{,}~`right`.`label`())</span>
The supported hash functions are described in
<span><a href="#sec_hash-registry" class="internal xref">2.3.2</a> (<a href="#sec_hash-registry" class="auto internal xref">Section 2.3.2</a>)</span>{reference-type="ref+label"
reference="sec:hash-registry"}.<a href="#section-2.5.1-4.5.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-2.5.1-4.6">
              <p id="section-2.5.1-4.6.1">$\mathbf s\gets <code>AndComposition</code>.<code>simulate_response</code>()$
generates a simulated response as follows:<a href="#section-2.5.1-4.6.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.5.1-4.6.2">
<li id="section-2.5.1-4.6.2.1">
                  <p id="section-2.5.1-4.6.2.1.1">$s_0\gets<code>left</code>.<code>simulate_response</code>()$<a href="#section-2.5.1-4.6.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.1-4.6.2.2">
                  <p id="section-2.5.1-4.6.2.2.1">$s_1\gets<code>right</code>.<code>simulate_response</code>()$<a href="#section-2.5.1-4.6.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.1-4.6.2.3">
                  <p id="section-2.5.1-4.6.2.3.1">Return $\mathbf s\coloneqq(s_0,s_1)$.<a href="#section-2.5.1-4.6.2.3.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li class="normal" id="section-2.5.1-4.7">
              <p id="section-2.5.1-4.7.1">$\mathbf T\gets <code>AndComposition</code>.<code>simulate_commitment</code>(c, \mathbf s)$
works as follows:<a href="#section-2.5.1-4.7.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.5.1-4.7.2">
<li id="section-2.5.1-4.7.2.1">
                  <p id="section-2.5.1-4.7.2.1.1">$(s_0,s_1)\coloneqq\mathbf s$.<a href="#section-2.5.1-4.7.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.1-4.7.2.2">
                  <p id="section-2.5.1-4.7.2.2.1">$T_0\gets<code>left</code>.<code>simulate_commitment</code>(c,s_0)$<a href="#section-2.5.1-4.7.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.1-4.7.2.3">
                  <p id="section-2.5.1-4.7.2.3.1">$T_1\gets<code>right</code>.<code>simulate_commitment</code>(c,s_1)$<a href="#section-2.5.1-4.7.2.3.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.1-4.7.2.4">
                  <p id="section-2.5.1-4.7.2.4.1">Return $\mathbf T\coloneqq(T_0, T_1)$.<a href="#section-2.5.1-4.7.2.4.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
          </ul>
<p id="section-2.5.1-5">::: warning
Witness equality Note that the AND-composition defined in the following
gives no guarantee about equality of the witnesses: if the same witness
is used across different clauses of the AND-composition, the protocol
will not guarantee that they are indeed the same. How to achieve such
claims is discussed in
<span><a href="#sec_linear_relations" class="internal xref">3.3</a> (<a href="#sec_linear_relations" class="auto internal xref">Section 3.3</a>)</span>{reference-type="ref+label"
reference="sec:linear_relations"}.
:::<a href="#section-2.5.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="or-composition">
<section id="section-2.5.2">
          <h4 id="name-or-composition">
<a href="#section-2.5.2" class="section-number selfRef">2.5.2. </a><a href="#name-or-composition" class="section-name selfRef">OR Composition</a>
          </h4>
<p id="section-2.5.2-1">In the following we explain how to construct a Sigma protocol proving
knowledge of one out of a set of witnesses, for instance one of a set of
secret keys (like ring signatures). That is, the algorithms specified
below constitute a Sigma protocol for the following relation:
<span class="contact-name">{\mathsf{R}_{øperatorname{or}}} = \set{     ((Y_0,Y_1),(w_0,w_1) :     (Y_0,w_0)∈ {\mathsf{R}_{øperatorname{{}}}}_0 ~łor~ (Y_1,w_1)∈{\mathsf{R}_{øperatorname{{}}}}_1} .</span><a href="#section-2.5.2-1" class="pilcrow">¶</a></p>
<p id="section-2.5.2-2">The statement $Y$ is the pair $(Y_0, Y_1)$ of the composing statements,
and the witness $w$ is the pair $(w_0, w_1)$ of the witnesses for the
respective relation. One of the witness can be set to $\mathsf{None}$.
In the following protocol specification, let $j$ be such that $w_j$ is
known to the prover, whereas without loss of generality $w_{1-j}$ is
assumed to be unknown to the prover.<a href="#section-2.5.2-2" class="pilcrow">¶</a></p>
<p id="section-2.5.2-3">On a high level, the protocol works as follows. Using the simulator, the
prover first simulates a transcript for the unknown witness (keeping the
challenge and response of this transcript temporarily secret), and
generates an honest commitment for the known witness. Having received
the challenge, the prover then computes challenge for the known witness,
depending on the received challenge and the one from the simulated
transcript. Having computed the response, the prover transfers the
responses of both transcripts, as well as the partial challenges to the
verifier, who accepts if and only if both instances of the partial
protocols output $\pctrue$ and the partial challenges correctly add up
to the random challenge.<a href="#section-2.5.2-3" class="pilcrow">¶</a></p>
<p id="section-2.5.2-4">The main procedures of the resulting Sigma protocol are specified by
the following algorithms:<a href="#section-2.5.2-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2.5.2-5.1">
              <p id="section-2.5.2-5.1.1">$<code>OrComposition</code>.<code>new</code>(<code>ctx</code>, <code>left</code>, <code>right</code>)$:
internally store <code>left}$ and $\texttt{right</code>.<a href="#section-2.5.2-5.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-2.5.2-5.2">
              <p id="section-2.5.2-5.2.1">$(\mathbf T, <code>pstate</code>)\gets <code>OrComposition</code>.<code>prover_commit</code>(\mathbf w)$:<a href="#section-2.5.2-5.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.5.2-5.2.2">
<li id="section-2.5.2-5.2.2.1">
                  <p id="section-2.5.2-5.2.2.1.1">$<code>Prover</code>= [<code>left</code>, <code>right</code>]$<a href="#section-2.5.2-5.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.2.2.2">
                  <p id="section-2.5.2-5.2.2.2.1">$(w_0,w_1)\coloneqq\mathbf w$, and let $j \in \bin$ be the first
index for which $w_{j}\neq\mathsf{None}$<a href="#section-2.5.2-5.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.2.2.3">
                  <p id="section-2.5.2-5.2.2.3.1">$(T_j,<code>pstate</code>_j)\gets<code>Prover</code>[j].<code>prover_commit</code>(Y_j,w_j)$<a href="#section-2.5.2-5.2.2.3.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.2.2.4">
                  <p id="section-2.5.2-5.2.2.4.1">$s_{1-j}\gets<code>Prover</code>[1-j].<code>simulate_response</code>()$<a href="#section-2.5.2-5.2.2.4.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.2.2.5">
                  <p id="section-2.5.2-5.2.2.5.1">Choose a random $c_{1-j}$ in $\mathcal{C}$<a href="#section-2.5.2-5.2.2.5.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.2.2.6">
                  <p id="section-2.5.2-5.2.2.6.1">$T_{1-j}\gets<code>Prover</code>[1-j].<code>simulate_commitment</code>(c_{1-j},s_{1-j})$<a href="#section-2.5.2-5.2.2.6.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.2.2.7">
                  <p id="section-2.5.2-5.2.2.7.1">Return
$(\mathbf T,<code>pstate</code>) \coloneqq((T_0,T_1),(<code>pstate</code><em>j,c</em>{1-j},s_{1-j}))$<a href="#section-2.5.2-5.2.2.7.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li class="normal" id="section-2.5.2-5.3">
              <p id="section-2.5.2-5.3.1">$\mathbf s\gets <code>OrComposition</code>.<code>prover_response</code>(<code>pstate</code>, c)$:<a href="#section-2.5.2-5.3.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.5.2-5.3.2">
<li id="section-2.5.2-5.3.2.1">
                  <p id="section-2.5.2-5.3.2.1.1">$(<code>pstate</code><em>j,c</em>{1-j},s_{1-j})\coloneqq<code>pstate</code>$<a href="#section-2.5.2-5.3.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.3.2.2">
                  <p id="section-2.5.2-5.3.2.2.1">$c_j\coloneqq c\oplus c_{1-j}$<a href="#section-2.5.2-5.3.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.3.2.3">
                  <p id="section-2.5.2-5.3.2.3.1">$s_j\gets<code>Prover</code>[j].<code>prover_response</code>(<code>pstate</code>_j, c_j)$<a href="#section-2.5.2-5.3.2.3.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.3.2.4">
                  <p id="section-2.5.2-5.3.2.4.1">Return $\mathbf s\coloneqq(s_0,s_1, c_0)$.<a href="#section-2.5.2-5.3.2.4.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li class="normal" id="section-2.5.2-5.4">
              <p id="section-2.5.2-5.4.1">$<code>OrComposition</code>.<code>verifier</code>(\mathbf T, c, \mathbf s)$,<a href="#section-2.5.2-5.4.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.5.2-5.4.2">
<li id="section-2.5.2-5.4.2.1">
                  <p id="section-2.5.2-5.4.2.1.1">$(s_0, s_1, c_0)\coloneqq\mathbf s$.<a href="#section-2.5.2-5.4.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.4.2.2">
                  <p id="section-2.5.2-5.4.2.2.1">$c_1\coloneqq c\oplus c_0$.<a href="#section-2.5.2-5.4.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.4.2.3">
                  <p id="section-2.5.2-5.4.2.3.1">Return $\pctrue$ if both
$<code>left</code>.<code>verifier</code>(T_0,c_0,s_0)$ and
$<code>right</code>.<code>verifier</code>(T_1,c_1,s_1)$ return
$\pctrue$. Otherwise, return $\pcfalse$.<a href="#section-2.5.2-5.4.2.3.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li class="normal" id="section-2.5.2-5.5">
              <p id="section-2.5.2-5.5.1">$<code>OrComposition</code>.<code>label</code>()$ is computed as:
<span class="contact-name">ℎash(\texttt{\textquotesingle{}or−composition\textquotesingle} \mathbf{∣}~`left`.`label`()  \textbf{,}~`right`.`label`())</span>
The supported hash functions are described in
<span><a href="#sec_hash-registry" class="internal xref">2.3.2</a> (<a href="#sec_hash-registry" class="auto internal xref">Section 2.3.2</a>)</span>{reference-type="ref+label"
reference="sec:hash-registry"}.<a href="#section-2.5.2-5.5.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-2.5.2-5.6">
              <p id="section-2.5.2-5.6.1">$\mathbf s\gets <code>OrComposition</code>.<code>simulate_response</code>()$<a href="#section-2.5.2-5.6.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.5.2-5.6.2">
<li id="section-2.5.2-5.6.2.1">
                  <p id="section-2.5.2-5.6.2.1.1">$(Y_0,Y_1)\coloneqq\mathbf Y$.<a href="#section-2.5.2-5.6.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.6.2.2">
                  <p id="section-2.5.2-5.6.2.2.1">$s_0\gets<code>left</code>.<code>simulate_response</code>()$<a href="#section-2.5.2-5.6.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.6.2.3">
                  <p id="section-2.5.2-5.6.2.3.1">$s_1\gets<code>right</code>.<code>simulate_response</code>()$<a href="#section-2.5.2-5.6.2.3.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.6.2.4">
                  <p id="section-2.5.2-5.6.2.4.1">Choose a random $c_0$ in $\mathcal{C}$.<a href="#section-2.5.2-5.6.2.4.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.6.2.5">
                  <p id="section-2.5.2-5.6.2.5.1">Return $\mathbf s\coloneqq(s_0,s_1,c_0)$.<a href="#section-2.5.2-5.6.2.5.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li class="normal" id="section-2.5.2-5.7">
              <p id="section-2.5.2-5.7.1">$\mathbf T\gets <code>OrComposition</code>.<code>simulate_commitment</code>(c, \mathbf s)$<a href="#section-2.5.2-5.7.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-2.5.2-5.7.2">
<li id="section-2.5.2-5.7.2.1">
                  <p id="section-2.5.2-5.7.2.1.1">$(s_0,s_1,c_0)\coloneqq\mathbf s$.<a href="#section-2.5.2-5.7.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.7.2.2">
                  <p id="section-2.5.2-5.7.2.2.1">$c_1\coloneqq c\oplus c_0$.<a href="#section-2.5.2-5.7.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.7.2.3">
                  <p id="section-2.5.2-5.7.2.3.1">$T_0 \gets<code>left</code>.<code>simulate_commitment</code>(c_0,s_0)$<a href="#section-2.5.2-5.7.2.3.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.7.2.4">
                  <p id="section-2.5.2-5.7.2.4.1">$T_1\gets<code>right</code>.<code>simulate_commitment</code>(c_1,s_1)$<a href="#section-2.5.2-5.7.2.4.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-2.5.2-5.7.2.5">
                  <p id="section-2.5.2-5.7.2.5.1">Return $\mathbf T\coloneqq(T_0,T_1)$.<a href="#section-2.5.2-5.7.2.5.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
          </ul>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="sec_instantiation">
<section id="section-3">
      <h2 id="name-sigma-protocols-on-elliptic">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-sigma-protocols-on-elliptic" class="section-name selfRef">Sigma protocols on elliptic curves</a>
      </h2>
<p id="section-3-1">The following section now presents concrete instantiations for of
Sigma protocols over elliptic curves.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">::: remark
Protocols for residue classes Because of their dominance, the
presentation in the following focuses on proof goals over elliptic
curves, therefore leveraging additive notation. For prime-order
subgroups of residue classes, all notation needs to be changed to
multiplicative, and references to elliptic curves (e.g.,
$\textsf{curve}$) need to be replaced by their respective counterparts
over residue classes.
:::<a href="#section-3-2" class="pilcrow">¶</a></p>
<div id="ciphersuite-registry">
<section id="section-3.1">
        <h3 id="name-ciphersuite-registry">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-ciphersuite-registry" class="section-name selfRef">Ciphersuite Registry</a>
        </h3>
<p id="section-3.1-1">We advise for the use of prime-order elliptic curves of size either 256
or 512 bits, depending on the desired security of the upper layers in
the protocol<span class="cref" id="_2">For instance, proving a DH relation with one fixed group element
such as a public key, might expose the protocol to cryptanalytic
attacks such as Brown-Gallant [@EPRINT:BroGal04] and Cheon's
attack [@EC:Cheon06], and some implementations might opt for larger
curve sizes. We consider these attacks out of scope for this
standardization effort, and believe this analysis should be deferred
to the concrete security study of the larger protocol.</span>.<a href="#section-3.1-1" class="pilcrow">¶</a></p>
<p id="section-3.1-2">::: center
  Curve       Identifier        Security Level           Sources
  ----------- ---------------- ---------------- -------------------------
  P-521       <code>'-p-521'</code>             256                [@fips2]
  P-256       <code>'-p-256'</code>             128                [@fips2]
  secp256k1   <code>'-secp256k1'</code>         128                 [@SECG]
  Ristretto   <code>'-ristretto'</code>         128         [@cfrg-ristretto-decaf]
  BLS12-381   <code>'-bls12-381'</code>         128                [@bls12]
:::<a href="#section-3.1-2" class="pilcrow">¶</a></p>
<p id="section-3.1-3">We denote with $\GG$ the prime-order group of the elliptic curve, with
$\FF_p$ the scalar field, and with $G$ the generator of $\GG$ chosen as
per the curve parameters. We assume that all above curve parameters also
provide the following group operations: check for equality, identity,
addition, and scalar multiplication. Optionally, implementation might
implement Pippenger's algorithm [@pippenger] for multi-scalar
multiplication. In addition, we consider:<a href="#section-3.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1-4.1">
            <p id="section-3.1-4.1.1">an identifier for the curve, chosen from the table above, and
denoted $\textsf{curve}$;<a href="#section-3.1-4.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-3.1-4.2">
            <p id="section-3.1-4.2.1">a deterministic sub-procedure $a \coloneqq<code>FromBytes</code>(b)$,
taking as input a bit string $b$ of length
$\ensuremath{\SI{32}{\byte}}$, and mapping it into an element
$a \sample \FF_p$;<a href="#section-3.1-4.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-3.1-4.3">
            <p id="section-3.1-4.3.1">a deterministic sub-procedure $s \coloneqq<code>Serialize</code>(P)$,
taking as input a group element $P \in \GG$ and returning a
fixed-length sequence of bits. For elliptic curve groups,
<code>Serialize</code> must provide a compressed representation of the
<em>affine</em> representation, such as the $x$-coordinate of $P$ and one
bit determining the sign of $y$.<a href="#section-3.1-4.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-3.1-4.4">
            <p id="section-3.1-4.4.1">a deterministic sub-procedure $P \coloneqq<code>Deserialize</code>(s)$,
taking a (fixed-length and curve-dependent) sequence of bits and
returning an elliptic curve point. This procedure may raise an
exception or output $\mathsf{None}$ if the conversion fails.<a href="#section-3.1-4.4.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="sec_basic_sigma">
<section id="section-3.2">
        <h3 id="name-basic-sigma-protocols-in-pr">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-basic-sigma-protocols-in-pr" class="section-name selfRef">Basic Sigma Protocols in prime-order groups</a>
        </h3>
<p id="section-3.2-1">We describe an abstract class for proving knowledge of a preimage under
an arbitrary <em>group homomorphism</em>, which is a mapping between two groups
respecting the structure of the groups. In particular, as will be
discussed in <span><a href="#sec_instantiations" class="internal xref">3.4</a> (<a href="#sec_instantiations" class="auto internal xref">Section 3.4</a>)</span>{reference-type="ref+label"
reference="sec:instantiations"}, many statements related to discrete
logarithms or representations in groups of prime order, can be expressed
as statements over group homomorphisms. For an in-depth discussion of
the underlying theory we refer to Cramer [@cramer97].<a href="#section-3.2-1" class="pilcrow">¶</a></p>
<p id="section-3.2-2">::: definition
<strong>Definition 1</strong>. <em>For two groups $\GG_1,\GG_2$, a function
$\varphi:\GG_1\to\GG_2:x\mapsto\varphi(x)$ is a *(group) homomorphism</em>,
if and only if for all $a,b\in\GG_1$ it holds that
$\varphi(a+b)=\varphi(a)+\varphi(b)$.*
:::<a href="#section-3.2-2" class="pilcrow">¶</a></p>
<p id="section-3.2-3">Readers not familiar with the notation of group homomorphism may think
of $\varphi$ as a linear function from $n$ elements into $m$ elements.<a href="#section-3.2-3" class="pilcrow">¶</a></p>
<p id="section-3.2-4">::: example
Discrete logarithm equalityphi_DLEQ Looking at the relation
${\mathsf{R}_{\operatorname{dleq}}}$, the relevant homomorphism is given by:
<span class="contact-name">φ_{øperatorname{dleq}} : \FF_p→\GG^2 : w↦ (wG,wH) .</span>
If equality of discrete logarithms within <em>different</em> groups of the same
prime order $p$ is to be proven, the homomorphism to be considered would
be:
<span class="contact-name">φ_{øperatorname{dleq}}' : \FF_p→\GG_1×\GG_2 : w↦ (wG,wH) ,</span>
where $G$ and $H$ would now be generators for $\GG_1$ and $\GG_2$,
respectively. All the techniques discussed in the remainder of this spec
equally apply to both cases.
:::<a href="#section-3.2-4" class="pilcrow">¶</a></p>
<p id="section-3.2-5">::: example
Representationphi_REP Looking at the relation
${\mathsf{R}_{\operatorname{rep}}}$, the relevant homomorphism is given by:
<span class="contact-name">φ_{øperatorname{rep}} : \FF_p^2→\GG : (w_1,w_2)↦ w_1 G + w_2 H .</span>
:::<a href="#section-3.2-5" class="pilcrow">¶</a></p>
<p id="section-3.2-6">[]{#sec:sigma-dlog label="sec:sigma-dlog"} We provide a generic template
for all Sigma protocols for statements of the following form over
DLOG groups:
<span class="contact-name">{\mathsf{R}_{øperatorname{dlog}}}=\set{((Y_1,\dots,Y_m),(w_1,\dots,w_n)) ∈ \GG^m × \FF_p^n: (Y_1,\dots,Y_m)=φ(w_1,\dots,w_n)}</span>
where $\varphi:\FF_p^n\to\GG^m$ is a group homomorphism.<a href="#section-3.2-6" class="pilcrow">¶</a></p>
<p id="section-3.2-7">::: remark
Selective disclosure of witnesses Note that in the following
descriptions, all witnesses are assumed to be kept secret, i.e., none of
them is disclosed to the verifier. In case it is required to disclose
$w_j$, as is the case, e.g., in the context of attribute-based
credential systems, the relation to be proven can be rewritten as
follows: <span class="contact-name">{\mathsf{R}_{øperatorname{dlog}}}'=\set{     \begin{array}{r}     ((Y_1',\dots,Y_m')),(w_1,\dots,w_{j−1},w_{j+1},\dots,w_n)) ∈ \GG^m × \FF_p^{n−1}: ~~~~~~~~~~~~\\     (Y_1',\dots,Y_m')=ψ(w_1,\dots,w_{j−1},w_{j+1},\dots,w_n)     \end{array}     }</span> where $$\begin{aligned}
    (Y_1',\dots,Y_m')                                   &amp;:= (Y_1,\dots,Y_m)-\varphi(0,\dots,0,w_j,0,\dots,0)\,\text{ and}<br>
      \psi(w_1,\dots,w_{j-1},w_{j+1},\dots,w_n) &amp;:= \varphi(w_1,\dots,w_{j-1},0,w_{j+1},\dots,w_n)\,.<a href="#section-3.2-7" class="pilcrow">¶</a></p>
<p id="section-3.2-8">\end{aligned}$$
:::<a href="#section-3.2-8" class="pilcrow">¶</a></p>
<p id="section-3.2-9">However, the following <em>defines neither the morphism nor the label
associated to the protocol</em>. These will be defined later in the specific
protocols.<a href="#section-3.2-9" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.2-10.1">
            <p id="section-3.2-10.1.1">$<code>DlogTemplate</code>.<code>new</code>(<code>ctx</code>, \mathbf Y)$
internally stores $\mathbf Y$ and <code>ctx</code>.<a href="#section-3.2-10.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-3.2-10.2">
            <p id="section-3.2-10.2.1">[]{#item:basic:p1 label="item:basic:p1"}
$(\mathbf T, <code>pstate</code>) \gets <code>DlogTemplate</code>.<code>prover_commit</code>(\mathbf w)$
consists of the following steps:<a href="#section-3.2-10.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3.2-10.2.2">
<li id="section-3.2-10.2.2.1">
                <p id="section-3.2-10.2.2.1.1">[]{#item:basic:p1:randomness label="item:basic:p1:randomness"}
Sample random elements $r_1,\dots,r_n\sample\FF_p$<a href="#section-3.2-10.2.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.2.2.2">
                <p id="section-3.2-10.2.2.2.1">$\mathbf T\coloneqq(T_1,\dots,T_m)\coloneqq\varphi(r_1,\dots,r_n)$<a href="#section-3.2-10.2.2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.2.2.3">
                <p id="section-3.2-10.2.2.3.1">$<code>pstate</code>\coloneqq(r_1,\dots,r_n)$<a href="#section-3.2-10.2.2.3.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.2.2.4">
                <p id="section-3.2-10.2.2.4.1">Return $(\mathbf T,<code>pstate</code>)$<a href="#section-3.2-10.2.2.4.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</li>
          <li class="normal" id="section-3.2-10.3">
            <p id="section-3.2-10.3.1">[]{#item:basic:p2 label="item:basic:p2"}
$\mathbf s\gets <code>DlogTemplate</code>.<code>prover_response</code>(<code>pstate</code>,c)$
proceeds as follows:<a href="#section-3.2-10.3.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3.2-10.3.2">
<li id="section-3.2-10.3.2.1">
                <p id="section-3.2-10.3.2.1.1">$(r_1,\dots,r_n)\coloneqq<code>pstate</code>$<a href="#section-3.2-10.3.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.3.2.2">
                <p id="section-3.2-10.3.2.2.1">$(w_1,\dots,w_n)\coloneqq\mathbf w$<a href="#section-3.2-10.3.2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.3.2.3">
                <p id="section-3.2-10.3.2.3.1">$e \coloneqq<code>FromBytes</code>(c)$.<a href="#section-3.2-10.3.2.3.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.3.2.4">
                <p id="section-3.2-10.3.2.4.1">For $i=1,\dots,n$: $s_i\coloneqq r_i+e w_i$<a href="#section-3.2-10.3.2.4.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.3.2.5">
                <p id="section-3.2-10.3.2.5.1">Return $\mathbf s\coloneqq(s_1,\dots,s_n)$.<a href="#section-3.2-10.3.2.5.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</li>
          <li class="normal" id="section-3.2-10.4">
            <p id="section-3.2-10.4.1">$<code>DlogTemplate</code>.<code>label</code>()$ return
$<code>morphism_label</code>()$.<a href="#section-3.2-10.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-3.2-10.5">
            <p id="section-3.2-10.5.1">[]{#item:basic:v label="item:basic:v"}
$<code>DlogTemplate</code>.<code>verifier</code>(\mathbf T,c,\mathbf s)$
proceeds as follows:<a href="#section-3.2-10.5.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3.2-10.5.2">
<li id="section-3.2-10.5.2.1">
                <p id="section-3.2-10.5.2.1.1">$(s_1, \dots, s_n) \coloneqq\mathbf s$<a href="#section-3.2-10.5.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.5.2.2">
                <p id="section-3.2-10.5.2.2.1">$(T_1, \dots, T_m) \coloneqq\mathbf T$<a href="#section-3.2-10.5.2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.5.2.3">
                <p id="section-3.2-10.5.2.3.1">$e \coloneqq<code>FromBytes</code>(c)$.<a href="#section-3.2-10.5.2.3.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.5.2.4">
                <p id="section-3.2-10.5.2.4.1">[]{#item:basic:v:checks label="item:basic:v:checks"} For
$i=1,\dots,n$: check $s_i\in\FF_p$<a href="#section-3.2-10.5.2.4.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.5.2.5">
                <p id="section-3.2-10.5.2.5.1">For $j=1,\dots,m$: check $T_j\in\GG$<a href="#section-3.2-10.5.2.5.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.5.2.6">
                <p id="section-3.2-10.5.2.6.1">Return $\pctrue$ if
$(T_1 + eY_1,\dots,T_m + eY_m) = \varphi(s_1,\dots,s_n)$;
$\pcfalse$ otherwise<a href="#section-3.2-10.5.2.6.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</li>
          <li class="normal" id="section-3.2-10.6">
            <p id="section-3.2-10.6.1">$\mathbf s\gets <code>DlogTemplate</code>.<code>simulate_response</code>()$:<a href="#section-3.2-10.6.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3.2-10.6.2">
<li id="section-3.2-10.6.2.1">
                <p id="section-3.2-10.6.2.1.1">Sample random elements $s_1,\dots,s_n\sample\FF_p$<a href="#section-3.2-10.6.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.6.2.2">
                <p id="section-3.2-10.6.2.2.1">Return $(s_1, \dots, s_n)$<a href="#section-3.2-10.6.2.2.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</li>
          <li class="normal" id="section-3.2-10.7">
            <p id="section-3.2-10.7.1">[]{#item:basic:sim label="item:basic:sim"}
$\mathbf T\gets <code>DlogTemplate</code>.<code>simulate_commitment</code>(c, \mathbf s)$:<a href="#section-3.2-10.7.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3.2-10.7.2">
<li id="section-3.2-10.7.2.1">
                <p id="section-3.2-10.7.2.1.1">$(Y_1,\dots,Y_m)\coloneqq\mathbf Y$.<a href="#section-3.2-10.7.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.7.2.2">
                <p id="section-3.2-10.7.2.2.1">[]{#item:basic:sim:s label="item:basic:sim:s"}
$(s_1,\dots,s_n) \coloneqq\mathbf s$.<a href="#section-3.2-10.7.2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.7.2.3">
                <p id="section-3.2-10.7.2.3.1">$e \coloneqq<code>FromBytes</code>(c)$.<a href="#section-3.2-10.7.2.3.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.7.2.4">
                <p id="section-3.2-10.7.2.4.1">$(T_1,\dots,T_m) \coloneqq\varphi(s_1,\dots,s_n) - e\cdot(Y_1,\dots,Y_m)$.<a href="#section-3.2-10.7.2.4.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-3.2-10.7.2.5">
                <p id="section-3.2-10.7.2.5.1">Output $\mathbf T\coloneqq(s_1,\dots,s_n)$.<a href="#section-3.2-10.7.2.5.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</li>
        </ul>
</section>
</div>
<div id="sec_linear_relations">
<section id="section-3.3">
        <h3 id="name-advanced-proving-linear-rel">
<a href="#section-3.3" class="section-number selfRef">3.3. </a><a href="#name-advanced-proving-linear-rel" class="section-name selfRef">Advanced: proving linear relations</a>
        </h3>
<p id="section-3.3-1">While the above protocol allows one to efficiently prove knowledge of a
pre-image under a homomorphism, many protocols found in the literature
require one to prove relations among witnesses. Specifically, they
require to prove relations like the following:
<span class="contact-name">{\mathsf{R}_{øperatorname{lin}}}=\set{((Y_1,\dots,Y_m),(w_1,\dots,w_n)) : \begin{array}{c} (Y_1,\dots,Y_m)=φ(w_1,\dots,w_n) \\                   A⋅(w_1,\dots,w_n)^⊺ = (b_1,\dots,b_k)^⊺\end{array}} ,</span>
where the matrix $A\in\FF_p^{k\times n}$ and vector
$(b_1,\dots,b_k)\in\FF_p^k$ specify the system of linear equations.<a href="#section-3.3-1" class="pilcrow">¶</a></p>
<p id="section-3.3-2">In the following, we sketch how such relations can be translated into
relations of the form discussed in
<span><a href="#sec_basic_sigma" class="internal xref">3.2</a> (<a href="#sec_basic_sigma" class="auto internal xref">Section 3.2</a>)</span>{reference-type="ref+label"
reference="sec:basic_sigma"}. We assume that $A$ is of the following
form: <span class="contact-name">A = łeft(\begin{array}{cccccccc}       a_{11}     &amp; \dots       &amp; a_{1k}    &amp; 1         &amp; 0       &amp; 0     &amp; \dots    &amp; 0\\       a_{21}     &amp; \dots       &amp; a_{2k}    &amp; 0         &amp; 1       &amp; 0     &amp; \dots    &amp; ⋮\\       ⋮     &amp;             &amp; ⋮    &amp; ⋮    &amp;         &amp; ⋮&amp;          &amp; 0\\       ⋮     &amp;             &amp; ⋮    &amp; ⋮    &amp;         &amp; 0     &amp; 1        &amp; 0\\       a_{k1}     &amp; \dots       &amp; a_{kk}    &amp; 0         &amp; \dots   &amp; \dots &amp; 0        &amp; 1\\     \end{array}\right)</span> Note that this is without loss of generality.
If the system of linear equations has a different form, the above form
can always be achieved using Gaussian elimination [@shoup08 Sec. 14.4]
and re-ordering of the witnesses. Note that we only need to consider the
case where $k&lt;n$, as otherwise the linear equations would uniquely
determine the witnesses, which is not desirable in our context.<a href="#section-3.3-2" class="pilcrow">¶</a></p>
<p id="section-3.3-3">The following relation ${\mathsf{R}<em>{\operatorname{lin}}}'$ is now
equivalent to that specified by ${\mathsf{R}</em>{\operatorname{lin}}}$:
<span class="contact-name">{\mathsf{R}_{øperatorname{lin}}}'=\set{((Y_1,\dots,Y_m),(w_1,\dots,w_{n−k})) : (Y_1,\dots,Y_m)=ψ(w_1,\dots,w_{n−k})}</span> where <span class="contact-name">\begin{aligned}   ψ(w_1,\dots,w_{n−k}) &amp;:= φ(w_1,\dots,w_{n−k},−∑_{i=1}^{n−k}a_{1i}w_i,\dots,−∑_{i=1}^{n−k}a_{ki}w_i) \text{ and}\\   (Y_1',\dots,Y_m')   &amp;:= (Y_1,\dots,Y_m) − φ(0,\dots,0,b_1,\dots,b_k) . \end{aligned}</span><a href="#section-3.3-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec_instantiations">
<section id="section-3.4">
        <h3 id="name-examples">
<a href="#section-3.4" class="section-number selfRef">3.4. </a><a href="#name-examples" class="section-name selfRef">Examples</a>
        </h3>
<p id="section-3.4-1">Let $\GG$ be a group over an elliptic curve with prime order $p$. Denote
with $G \in \GG$ a generator of $\GG$.<a href="#section-3.4-1" class="pilcrow">¶</a></p>
<div id="sec_instantiations_schnorr">
<section id="section-3.4.1">
          <h4 id="name-schnorr-signatures">
<a href="#section-3.4.1" class="section-number selfRef">3.4.1. </a><a href="#name-schnorr-signatures" class="section-name selfRef">Schnorr signatures</a>
          </h4>
<p id="section-3.4.1-1">Schnorr signatures, also known as Schnorr proofs or DLOG proofs, prove
knowledge of the discrete logarithm $w\in \FF_p$ of a point $Y=wG$ in
base $G$.<a href="#section-3.4.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.4.1-2.1">
              <p id="section-3.4.1-2.1.1">$\varphi:\FF_p\to\GG:w\mapsto wG$<a href="#section-3.4.1-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-3.4.1-2.2">
              <p id="section-3.4.1-2.2.1">$<code>Schnorr</code>.<code>morphism_label</code>()$: return:
<span class="contact-name">ℎash(\texttt{\textquotesingle{}schnorrsig\textquotesingle} \textbf{,}~\textsf{curve} \mathbf{∣}~`Serialize`(G)  \textbf{,}~`Serialize`(Y))</span><a href="#section-3.4.1-2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-3.4.1-3">For a description of this proof goal in the general case of residue
classes, we also refer to [@zkproof-reference 1.4.1].<a href="#section-3.4.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="discrete-logarithm-equality">
<section id="section-3.4.2">
          <h4 id="name-discrete-logarithm-equality">
<a href="#section-3.4.2" class="section-number selfRef">3.4.2. </a><a href="#name-discrete-logarithm-equality" class="section-name selfRef">Discrete logarithm equality</a>
          </h4>
<p id="section-3.4.2-1">So-called DLEQ proofs prove equality of the discrete logarithm, that is:
$Y_1 = wG$ and $Y_2 = wH$.<a href="#section-3.4.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.4.2-2.1">
              <p id="section-3.4.2-2.1.1">$\varphi:\FF_p\to\GG^2:w\mapsto (wG,wH)$<a href="#section-3.4.2-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-3.4.2-2.2">
              <p id="section-3.4.2-2.2.1">$<code>Dleq</code>.<code>morphism_label</code>()$: return
<span class="contact-name">ℎash(\texttt{\textquotesingle{}dleq\textquotesingle} \textbf{,}~\textsf{curve} \mathbf{∣}~`Serialize`(G)  \textbf{,}~`Serialize`(H)  \textbf{,}~`Serialize`(Y_1)  \textbf{,}~`Serialize`(Y_2))</span><a href="#section-3.4.2-2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</section>
</div>
<div id="diffie-hellman">
<section id="section-3.4.3">
          <h4 id="name-diffie-hellman">
<a href="#section-3.4.3" class="section-number selfRef">3.4.3. </a><a href="#name-diffie-hellman" class="section-name selfRef">Diffie-Hellman</a>
          </h4>
<p id="section-3.4.3-1">Let $\GG$ be a group over an elliptic curve with prime order $p$.
Proving knowledge of the exponents of a valid Diffie-Hellman triple
means proving knowledge of $w_1,w_2\in\FF_p$ such that $Y_1=w_1G$,
$Y_2=w_2G$, and $Y_3=w_1 w_2 G$. The mapping
$\FF_p^2\to\GG^3:(w_1,w_2)\mapsto (w_1G,w_2G,w_1w_2G)$ is not a
homomorphism, and consequently the basic protocol presented before
cannot be deployed directly. However, the required multiplicative
relation can be proven by observing that the proof goal is equivalent to
$Y_1=w_1G$, $Y_2=w_2G$, and $Y_3=w_2Y_1$, leading the homomorphism<a href="#section-3.4.3-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.4.3-2.1">
              <p id="section-3.4.3-2.1.1">$\varphi:\FF_p^2\to\GG^3:(w_1,w_2)\mapsto(w_1G,w_2G,w_2Y_1)$<a href="#section-3.4.3-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-3.4.3-2.2">
              <p id="section-3.4.3-2.2.1">$<code>Dh</code>.<code>morphism_label</code>()$ return:
<span class="contact-name">ℎash(\texttt{\textquotesingle{}diffie−hellman\textquotesingle} \textbf{,}~\textsf{curve} \mathbf{∣}~`Serialize`(G)  \textbf{,}~`Serialize`(Y_1)  \textbf{,}~`Serialize`(Y_2))</span><a href="#section-3.4.3-2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-3.4.3-3">As shown in this example, and in contrast to linear relations,
multiplicative relations among witnesses typically require a
reformulation of the proof goal.<a href="#section-3.4.3-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec_instantiations_representation">
<section id="section-3.4.4">
          <h4 id="name-representation">
<a href="#section-3.4.4" class="section-number selfRef">3.4.4. </a><a href="#name-representation" class="section-name selfRef">Representation</a>
          </h4>
<p id="section-3.4.4-1">Let $\GG$ be a group over an elliptic curve of prime order $p$, and let
$G_1, \dots, G_m$ be generators of $\GG$. Proving knowledge of a valid
opening of a Pedersen commitment means proving knowledge of
$w_1,w_2, \dots, w_m\in\FF_p$ such that
$Y=w_1G_1 + w_2G_2 + \dots + w_m G_m$.<a href="#section-3.4.4-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.4.4-2.1">
              <p id="section-3.4.4-2.1.1">$\varphi:\FF_p^m\to\GG:(w_1,w_2, \dots, w_m)\mapsto \sum_i w_iG_i$<a href="#section-3.4.4-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-3.4.4-2.2">
              <p id="section-3.4.4-2.2.1">$<code>Rep</code>.<code>morphism_label</code>()$ returns
<span class="contact-name">ℎash(\texttt{\textquotesingle{}representation\textquotesingle} \textbf{,}~\textsf{curve} \mathbf{∣}~`Serialize`(G_1)  \textbf{,}~⋅s  \textbf{,}~`Serialize`(G_m)  \textbf{,}~`Serialize`(Y))</span><a href="#section-3.4.4-2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-3.4.4-3">::: example
Range proofs via bit decomposition Let $\GG$ be a cyclic group of prime
order $p$, and let $G$ and $H$ be generators of $\GG$, and let $\ell$ be
a non-negative integer satisfying $\ell&lt;\log_2 p$. Consider the
following relation:
<span class="contact-name">{\mathsf{R}_{øperatorname{range}}} = \set{łeft(Y,(w_1,w_2))\right)~:~Y=w_1 G +w_2 H ~łand~ w_1∈[0,2^ℓ)} .</span>
Multiple techniques for proving that a secret witness lies within a
certain range, cf. Morais et al. [@range-proof-survey] for a survey. We
will use the so-called <em>bit decomposition</em> approach.<a href="#section-3.4.4-3" class="pilcrow">¶</a></p>
<p id="section-3.4.4-4">To do so, the prover computes $w_{1,i}\in\set{0,1}$ for
$i=0,\dots,\ell-1$ such that $w_1=\sum_{i=0}^{\ell-1}2^iw_{1,i}$, and
computes commitments to those individual bits, i.e.,
$Y_i=w_{1,i}G+w_{2,i}H$ for $w_{2,i}\sample\FF_p$. Furthermore, it sets
$w^*=w_2-\sum_{i=0}^{\ell-1}2^iw_{2,i}$.<a href="#section-3.4.4-4" class="pilcrow">¶</a></p>
<p id="section-3.4.4-5">Assuming that the discrete logarithm problem is hard in $\GG$, the above
relation is now equivalent to the following relation: $$\begin{aligned}
      {\mathsf{R}<em>{\operatorname{range}}}' = \bigg{\left((Y,(Y_i)</em>{i=0}^{\ell-1}),(w_1,w_2,(w_{2,i})<em>{i=0}^{\ell-1}),w^*)\right)~:~         Y=w_1 G +w_2 H ~\land~ <br>
        Y-\sum</em>{i=0}^{\ell-1} 2^iY_i = w^* H ~\land~  <br>
        \bigwedge_{i=0}^{\ell-1} \left(Y_i=w_{2,i}H ~\lor~ Y_i-G=w_{2,i}H\right)\bigg}\,.<a href="#section-3.4.4-5" class="pilcrow">¶</a></p>
<p id="section-3.4.4-6">\end{aligned}$$<a href="#section-3.4.4-6" class="pilcrow">¶</a></p>
<p id="section-3.4.4-7">It can now be seen that the above ensures knowledge of the witnesses $w_1$
hidden within $Y$. Furthermore, we guarantee that the values hidden within
$Y_i$ correctly add up to $w_1$, i.e., that
$w_1-\sum_{i=0}^{\ell-1}2^iw_{1,i}=0$. Finally, the two clauses
ensure that each $Y_i$ is a commitment to
either $0$ or $1$, thus implying the bound on $w_1$.<a href="#section-3.4.4-7" class="pilcrow">¶</a></p>
<p id="section-3.4.4-8">The different clauses can
finally be composed using nested protocol compositions from
<span><a href="#sec_composition" class="internal xref">2.5</a> (<a href="#sec_composition" class="auto internal xref">Section 2.5</a>)</span>{reference-type="ref+label"
reference="sec:composition"}.
:::<a href="#section-3.4.4-8" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="batch-verification">
<section id="section-3.5">
        <h3 id="name-batch-verification">
<a href="#section-3.5" class="section-number selfRef">3.5. </a><a href="#name-batch-verification" class="section-name selfRef">Batch verification</a>
        </h3>
<p id="section-3.5-1">The batchable form can take advantage of the following fact. Given
$\ell$ verification equations of the form:
<span class="contact-name">T_i + c_i Y_i = ∑_j s_j G_{i,j}</span> for $i=1, \dots,\ell$, the
verifier can sample a random vector of coefficients
$\mathbf a \in \FF_p^\ell$ and instead test:
<span class="contact-name">łeft(∑_{i=1}^{ℓ} a_i T_i\right) + łeft(∑_{i=1}^{ℓ} a_i ⋅  c_i Y_i \right) = łeft(∑_{i=1}^{ℓ} a_i ⋅ ∑_j s_j G_{i,j}\right).</span>
If the matrix $G_{i, j}$ of generators has identical rows, by linearity
the right-hand side can be computed as a single scalar product. If the
statements $Y_i$'s have identical rows, by linearity the second term in
the equation can be computed as a single scalar product.<a href="#section-3.5-1" class="pilcrow">¶</a></p>
<p id="section-3.5-2">In any case, the test can be efficiently implemented as a single
multiscalar multiplication, minimizing the number of group operations
needed:
<span class="contact-name">łeft(∑_{i=1}^{ℓ} a_i T_i\right) + łeft(∑_{i=1}^{ℓ} (a_i ⋅  c_i) Y_i \right) + łeft(∑_{i=1}^{ℓ}∑_j (−a_i ⋅  s_j) G_{i,j}\right) = 0.</span><a href="#section-3.5-2" class="pilcrow">¶</a></p>
<p id="section-3.5-3">The random vector $\mathbf a$ can be <em>deterministically</em> generated by
fixing $a_1 \coloneqq 1$ and setting
$(a_2, \dots, a_{\ell}) \coloneqq\prg(\hash(c\,\textbf{,}~\mathbf s))$ [@bip-schnorr].<a href="#section-3.5-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="encoding-the-statement">
<section id="section-4">
      <h2 id="name-encoding-the-statement">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-encoding-the-statement" class="section-name selfRef">Encoding the statement</a>
      </h2>
<p id="section-4-1">Statements in Sigma protocols take the form of a labeled binary tree:
<code>Statement</code> is either:<a href="#section-4-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4-2.1">
          <p id="section-4-2.1.1">a label [AND]{.sans-serif}, or [OR]{.sans-serif}, and two children
[left]{.sans-serif} and [right]{.sans-serif} of type
<code>Statement</code><a href="#section-4-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-4-2.2">
          <p id="section-4-2.2.1">a $<code>StatementLeaf</code>$ instance. Objects of this type depend on
the specific algebraic setting used, and will be treated later.<a href="#section-4-2.2.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-4-3">Statements are serialized depth-first. There are many different options
for serialization that could be considered:<a href="#section-4-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4-4.1">
          <p id="section-4-4.1.1">Concise Binary Object Representation (CBOR)
<a href="https://datatracker.ietf.org/doc/html/rfc7049">RFC7049</a><a href="#section-4-4.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-4-4.2">
          <p id="section-4-4.2.1">The zk proof Reference document provides a serialization document
for r1cs [@zkproof-reference 3.4.2], but there is nothing in it.<a href="#section-4-4.2.1" class="pilcrow">¶</a></p>
</li>
      </ul>
</section>
</div>
<div id="additional-proof-types">
<section id="section-5">
      <h2 id="name-additional-proof-types">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-additional-proof-types" class="section-name selfRef">Additional proof types</a>
      </h2>
<p id="section-5-1">Other protocols are not included here and are not part of the scope of
the current version of this spec.<a href="#section-5-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5-2.1">
          <p id="section-5-2.1.1">mpc-in-the-head protocol such as ZKBoo [@USENIX:GiaMadOrl16]<a href="#section-5-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-5-2.2">
          <p id="section-5-2.2.1">one-out-of-many proofs such as [@EC:GroKoh15]<a href="#section-5-2.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-5-2.3">
          <p id="section-5-2.3.1">lwe-based sigma protocol [@C:AttCraKoh21]<a href="#section-5-2.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-5-2.4">
          <p id="section-5-2.4.1">syndrome decoding and LPN [@C:Stern93; @AC:JKPT12]<a href="#section-5-2.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
</section>
</div>
<div id="acknowledgments">
<section id="section-6">
      <h2 id="name-acknowledgments">
<a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
      </h2>
<p id="section-6-1">Jan Bobolz, Mary Maller, Ivan Visconti, Yuwen Zhang.<a href="#section-6-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-A">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Michele Orrù</span></div>
<div dir="auto" class="left"><span class="org">CNRS</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:m@orru.net" class="email">m@orru.net</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Stephan Krenn</span></div>
<div dir="auto" class="left"><span class="org">AIT</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:stephan.krenn@ait.ac.at" class="email">stephan.krenn@ait.ac.at</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
