



Network Working Group                                            M. Orrù
Internet-Draft                                                      CNRS
Intended status: Informational                                  S. Krenn
Expires: 19 October 2024                                             AIT
                                                           17 April 2024


                            Sigma Protocols
                    draft-orru-zkproof-sigma-latest

Abstract

   This document describes Sigma protocols, a secure, general-purpose
   non-interactive zero-knowledge proof of knowledge.  Concretely, the
   scheme allows proving knowledge of the pre-representation of
   different group elements, without revealing any information about the
   undisclosed messages or the signature itself, while at the same time,
   guarantying soundness of the overall protocols.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://mmaker.github.io/stdsigma/draft-orru-zkproof-sigma.html.
   Status information for this document may be found at
   https://datatracker.ietf.org/doc/draft-orru-zkproof-sigma/.

   Source for this draft and an issue tracker can be found at
   https://github.com/mmaker/stdsigma.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 19 October 2024.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
     1.1.  Terminology
     1.2.  Notation
     1.3.  Document Organization
     1.4.  Scope of this document
   2.  Sigma protocols definition
     2.1.  Overview
     2.2.  An abstract class for generic Sigma protocols
     2.3.  The Fiat-Shamir Transform
       2.3.1.  Syntax
       2.3.2.  Hash Registry
       2.3.3.  Computing the challenge and seeding the commitment
       2.3.4.  Non-interactive proofs
       2.3.5.  Batchable Proofs
       2.3.6.  Short Proofs
     2.4.  Input validation
     2.5.  Composition of Sigma Protocols
       2.5.1.  AND Composition
       2.5.2.  OR Composition
   3.  Sigma protocols on elliptic curves
     3.1.  Ciphersuite Registry
     3.2.  Basic Sigma Protocols in prime-order groups
     3.3.  Advanced: proving linear relations
     3.4.  Examples
       3.4.1.  Schnorr signatures
       3.4.2.  Discrete logarithm equality
       3.4.3.  Diffie-Hellman
       3.4.4.  Representation
     3.5.  Batch verification
   4.  Encoding the statement
   5.  Additional proof types
   Acknowledgments
   Authors' Addresses

1.  Introduction

   Zero-knowledge proofs of knowledge allow a prover to convince a
   verifier that they know a secret piece of information, without
   revealing anything except that the claim itself already reveals.
   Many practically relevant proof goals can be realized using so-called
   Sigma protocols.  Introduced by Schnorr over 30 years ago, they play
   an essential component in the building of a number of cryptographic
   constructions, such as anonymous credentials, password-authenticated
   key exchange, signatures, ring signatures, blind signatures, multi
   signatures, threshold signatures and more.  This spec provides
   guidelines for correctly implementing Sigma protocols.

1.1.  Terminology

   Given sets $\mathcal{Y}$ and $\mathcal{W}$, a _binary relation_
   ${\mathsf{R}}\subseteq \mathcal{Y} \times \mathcal{W}$ associates
   elements from $\mathcal{Y}$ with elements from $\mathcal{W}$. For
   $(Y,w)\in{\mathsf{R}}$, we refer to $Y$ as a _statement_, and to $w$
   as a _witness_ (for $Y$).  The statement is public information shared
   between prover and verifier.  The witness is secret information
   solely known by the prover.  Note there may be multiple witnesses for
   a given $Y$.

   ::: example Discrete logarithm equality R_DLEQ Let $\GG$ be a cyclic
   group of prime order $p$, and let $G$ and $H$ be generators of $\GG$.
   Then the following relation ${\mathsf{R}_{\operatorname{dleq}}}$
   contains as statements all pairs of elements having the same discrete
   logarithm with respect to $G$ and $H$, with the corresponding witness
   being their discrete logarithm: {\mathsf{R}_{øperatorname{dleq}}} =
   \set{łeft((Y_1,Y_2),w\right) ∈ \GG^2× \FF_p~:~Y_1=wG ~łand~ Y_2=wH} .
   :::

   ::: example RepresentationR_REP Let $\GG$ be a cyclic group of prime
   order $p$, and let $G$ and $H$ be generators of $\GG$. Then the
   following relation ${\mathsf{R}_{\operatorname{rep}}}$ contains as
   statements all valid Perdersen commitments, with the corresponding
   witnesses being their openings: {\mathsf{R}_{øperatorname{rep}}} =
   \set{łeft(Y,(w_1,w_2)\right)∈ \GG × \FF_p^2~:~Y=w_1G + w_2H} . Note
   that in this case, each statement has $p$ valid witnesses. :::

   In a zero-knowledge proof, the _witness_ is secret information, while
   the _statement_ is public.  A _proof_ is a sequence of bytes
   attesting that a witness is in some relation with the statement.

   Proofs described in this spec are zero-knowledge and sound.  Zero
   knowledge means that the protocol does not leak any information about
   the prover's witness beyond what the attacker may infer from the
   proven statement or from other sources [@zkproof-reference 1.6.4].
   Soundness means that it is not possible to make the verifier accept
   for statements for which no valid witness exists [@zkproof-reference
   1.6.2].

   In particular we will focus on non-malleable extractable proofs, that
   is, proofs where the the witness does not only exist but is also
   precisely known by the prover.  These protocols are also known as
   proofs of knowledge [@STOC:GolMicRac85; @STOC:FeiFiaSha87;
   @C:BelGol92] and are said to satisfy _knowledge
   soundness_ [@damgard04].  Non-malleability means that, in addition,
   the proof is secure against man-in-the middle attacks, and attackers
   cannot produce a new valid proof by tampering another valid proof.

1.2.  Notation

   Additional notation will be introduced when describing specific
   algebraic objects.

1.3.  Document Organization

1.4.  Scope of this document

   This document provides guidelines for secure implementations of Sigma
   protocols and is addressed to applied cryptographers and
   cryptographic engineers that are looking to implement a generic Sigma
   protocol or provide an ad-hoc instantiation as part of a larger
   protocols.

   We consider the problem of having a high-quality entropy source well-
   suited for cryptographic purposes outside of the scope of this
   document.  We will not talk about implementation of cryptographic
   primitives such as hash functions, or elliptic-curve algebra, but we
   will provide references for where to find them.  We won't provide any
   guidance for securely storing secrets or producing constant-time
   code.

2.  Sigma protocols definition

   In the following, we describe a generic interface for Sigma
   protocols.  Such protocols can be used to prove that, for some binary
   relation ${\mathsf{R}}$ and a public value $Y$, a witness $w$ such
   that $(Y,w)\in{\mathsf{R}}$ is known.  Basic statements include
   proofs of knowledge of a secret key, openings of commitments, and
   more in general of representations.  The type of these elements
   depends on the specific relation being implemented.

   An important property of Sigma protocols is that they are composable:
   it is possible to prove conjunction and disjunctions of statements in
   zero-knowledge.  Composition of Sigma protocols is dealt separately;
   for an in-depth discussion of the underlying theory we refer to
   Cramer [@cramer97].

2.1.  Overview

   Any Sigma protocol is structured as follows:

   *  the prover computes a fresh *commitment*, denoted $T$. This
      element is sometimes also called _nonce_.

   *  the prover computes, using the so-called Fiat-Shamir transform, a
      random *challenge*, denoted $c$.

   *  the prover computes a *response*, denoted $s$, that depends on the
      commitment and the challenge.

   The final proof is constituted of the three-elements above $(T, c,
   s)$, and is also referred to as the *transcript*.

2.2.  An abstract class for generic Sigma protocols

   We define a template class for Sigma protocols denoted SigmaProtocol.
   This is the basic interface that will be implemented remainder of
   this document.  The methods composing SigmaProtocol should be
   considered _private_ and _should not_ be exposed externally.  The
   public API is described later.  Instances are created via the new
   function, which is a class method, while all other functions act on a
   particular instance.  A SigmaProtocol consists of the following
   methods:

   *  $SigmaProtocol.new(ctx, Y)$, denoting the initialization function.
      This function takes as input a label identifying local context
      information ctx (such as: session identifiers, to avoid replay
      attacks; protocol metadata, to avoid hijacking; optionally, a
      timestamp and some pre-shared randomness, to guarantee freshness
      of the proof) and a statement $Y$, the public information shared
      between prover and verifier.  This function _should_ pre-compute
      parts of the statement, or initialize the state of the hash
      function.

   *  $(T, pstate)\gets SigmaProtocol.prover_commit(w)$, denoting the
      _commitment phase_, that is, the computation of the first message
      sent by the prover in a Sigma protocol.  This method outputs a new
      commitment together with its associated prover state, depending on
      the witness known to the prover and the statement to be proven.
      This step generally requires access to a high-quality entropy
      source.  Leakage of even just of a few bits of the nonce could
      allow for the complete recovery of the witness [@lattice-attack;
      @bleichenbacher; @CCS:ANTTY20].  The value $T$ is meant to be
      shared, while pstate must be kept secret.

      In particular, we assume that there exists a function
      $Serialize(T)$ that serializes the commitment $T$ and that its
      size is fixed and implicitly determined by the statement $Y$.

   *  $s\gets SigmaProtocol.prover_response(pstate, c)$, denoting the
      _response phase_, that is, the computation of the second message
      sent by the prover, depending on the witness, the statement, the
      challenge received from the verifier, and the internal state
      generated by prover_commit.  The value $s$ is meant to be shared.

   *  $yesno \gets SigmaProtocol.verifier(T, c, s)$, denoting the
      _verifier algorithm_. This method checks that the _protocol
      transcript_ is valid for the given statement.  The verifier
      algorithm outputs nothing if verification succeeds, or an error if
      verification fails.

   *  $label \getsSigmaProtocol.label()$, returning a string of
      $\ensuremath{\SI{32}{\byte}}$ uniquely identifying the relation
      being proven.  Implementing this function correctly is vital for
      security, and it must include all data available in the statement,
      as well as the parameters and the relation being proven.  The
      label will be used for computing the challenge in the Fiat-Shamir
      transform.  Precise indications on how to implement this function
      will be given in the following sections.

      If the label is _not_ tied to the relation, then it may be
      possible to produce another proof for a different relation without
      knowing its witness.  Similarly, if the statement is not tied to
      the label, then it may be possible to produce proofs for another
      statement whose witness is related to the original proof.

   The final two algorithms describe the _zero-knowledge simulator_. The
   simulator is primarily an efficient algorithm for proving zero-
   knowledge in a theoretical construction [@becafi19], but it is also
   needed for verifying short proofs and for or-composition, where a
   witness is not known and thus has to be simulated.  We have:

   *  $s\gets SigmaProtocol.simulate_response()$, denoting the first
      stage of the _simulator_. It is an algorithm drawing a random
      response that follows the same output distribution of the
      algorithm prover_response.

   *  $T\gets SigmaProtocol.simulate_commitment(c, s)$, denoting the
      second stage of the _simulator_, returning a commitment that
      follows the same output distribution of the algorithm
      prover_commit.

2.3.  The Fiat-Shamir Transform

   The interactive versions of the Sigma protocols presented in this
   document are not fit for practical applications, due to subtle yet
   impactful details in their security guarantees.  In practice, public-
   coin protocols such as Sigma protocols can be converted into non-
   interactive ones through the Fiat and Shamir heuristic [@C:FiaSha86]
   and subsequent work, e.g., by Bernhard, Pereira and
   Warinschi [@AC:BerPerWar12].

   The underlying idea is to replace the verifier with a
   cryptographically secure hash function, hashing the context from the
   protocol and the previous message sent by the prover.

   ::: warning Interactive Sigma protocols Sigma protocols illustrated
   in this spec *must not* be used interactively. :::

2.3.1.  Syntax

   When using a hash function we will employ comma-separated values to
   indicate values that are concatenated.  To mitigate attacks and allow
   for state cloning, we also separate values with semi-colons to
   indicate that they must appear in a subsequent block and that the
   previous is padded with zeros.  For instance, with the writing
   $\hash(a \,\textbf{,}~b \,\mathbf{\mid}~c)$ we denote the hashing of
   $a$ concatenated to $b$, then padded with the null byte until to
   reach the closest multiple of BLOCK_LEN bytes added, then and
   concatenate the resulting bit string to $c$.

2.3.1.1.  Constants.

   Different hash functions may rely on different constants.  We define
   some of the parameters associated to the hash function that will be
   used throughout this spec.

   ::: center Const name Notes ------------------------ ----------------
   ---------------------------------------------------------------------
   ------------------------ DOMSEP}$ Domain separator for this standard.
   Fixed to $\texttt{\textquotesingle{}zkpstd/sigma/0.1\textquotesingle.
   BLOCK_LEN Length of a hash block DIGEST_LEN Digest length :::

2.3.2.  Hash Registry

   This is the set of all supported hash functions.  They take an
   arbitrary length sequence of bytes as input, and output
   $\ensuremath{\SI{32}{\byte}}$ of entropy.

   ::: center Hash Source BLOCK_LEN}$ $\texttt{DIGEST_LEN ----------
   ---------------- ----------------------- ------------------------ --
   blake2b [@ACNS:ANWW13] 128 64 sha3-256 [@EC:BDPA13] 136 32 :::

   Supported hash functions must all have $BLOCK_LEN\geq 32$. We define
   labels and constant strings so that their length is always at most
   $\ensuremath{\SI{32}{\byte}}$. If $DIGEST_LEN\ge 32$, we implicitly
   assume that the implementation considers only the least significant
   bytes and discards the remainder of the hash output when exactly
   $\ensuremath{\SI{32}{\byte}}$ bytes are needed.

2.3.3.  Computing the challenge and seeding the commitment

   Relying on a hash function allows us to both compute the challenge
   and generate the commitment securely.  We define the following
   auxiliary variables that may be pre-computed during the call of
   $SigmaProtocol.new(ctx, Y)$. All variables will have fixed length
   DIGEST_LEN so to avoid canonicalization attacks.

2.3.3.1.  Seeding the commitment.

   The method $SigmaProtocol.prover_commit()$ is a randomized function
   that generates a random element, unique per each execution.  The
   commitment _should_ be seeded as follows:

   If the output length DIGEST_LEN of the hash function is not
   sufficient to provide enough entropy for the commitment, the seed may
   be expanded with a PRNG to provide the quantity of random bytes
   desired.

2.3.3.2.  Computing the challenge.

   The method $SigmaProtocol.challenge(\mu, T)$ is implemented as
   follows in order to produce a random challenge.

   If no message is being set, i.e. if $\mu= \mathsf{None}$, then the
   implementation may decide to skip the computation of $\text{hm}$ and
   consider it empty.  This method is fixed for all implementations of
   SigmaProtocol.  Note that the state of the hash function is partially
   shared between the commitment seed inputs and the challenge
   computation.  Implementors may choose to store the partial hash state
   before generating the commitment, and reuse it when computing the
   challenge.

2.3.4.  Non-interactive proofs

   We define two _public methods_ for generating proofs, meant to be
   exposed externally: short_proof, and batchable_proof.  Since the
   challenge is computed deterministically from the commitment and the
   statement, it is not necessary to include the full transcript in a
   proof, as it can be deduced in the verification phase.

   Short proofs are the most efficient if the protocol contains at least
   an _AND_ composition, and the gain in size is measured as $|\mathbf
   T| - DIGEST_LEN$. (Note: the length of the commitment is the length
   of the statement.)  Batchable proofs are the canonical forms of
   proofs.  Provers in the batchable form may raise an exception if the
   statement is not valid.  Proofs are seen as fixed-length bit strings,
   whose exact length can be inferred from the statement during
   initialization of the Sigma protocol.

   ::: remark Witness validation In the following we assume correctness
   of the witness $w$ for the given statement $Y$. This can be ensured,
   e.g., by a higher-level application, or by running
   $SigmaProtocol.verifier(T, c, s)$ before sending the resulting proof.
   :::

2.3.5.  Batchable Proofs

   Prover algorithm.  The public function
      $SigmaProtocol.batchable_proof( w, \mu)$ computes:

      1.  $(T,pstate)\getsSigmaProtocol.prover_commit( w)$.

      2.  $c \gets SigmaProtocol.challenge(\mu,T)$

      3.  $s\getsSigmaProtocol.prover_response(pstate, c)$. Return
          $Serialize(T)$ concatenated to $Serialize(\mathbf s)$

      The challenge $c$ is not provided within a batchable proof since
      it can be re-computed from the commitment.

   Verifier algorithm.  The verifier's algorithm
      $SigmaProtocol.batchable_verify(\pi, \mu)$ works as follows:

      1.  $(T,s) \coloneqqDeserialize(\pi)$

      2.  $c \gets SigmaProtocol.challenge(\mu, T)$

      3.  Return whatever $SigmaProtocol.verifier(T,c, s)$ returns.

      ::: warning Input validation The case of batched verification must
      include an input validation sub-routine that asserts the statement
      and commitments are in question.  In the case of elliptic curves,
      this boils down to point validation.  Failure to properly check
      that a commitment is in the group could lead to subgroup
      attacks [@EC:VanWie96; @C:LimLee97] or invalid curve
      attacks [@C:BieMeyMul00; @RSA:BBPV12]. :::

2.3.6.  Short Proofs

   Prover algorithm.  A new proof $SigmaProtocol.short_proof(w, \mu)$ is
      built as follows:

      1.  $(T,pstate)\getsSigmaProtocol.prover_commit(w)$.

      2.  $c \gets SigmaProtocol.challenge(\mu, T)$

      3.  $\mathbf s\getsSigmaProtocol.prover_response(pstate,c)$.

      4.  Return $Serialize(c)$ concatenated to $Serialize(s)$.

      The commitment $T$ is not provided within a short proof since it
      can be calculated again.

   Verifier algorithm.  The verifier's algorithm
      $SigmaProtocol.short_verify(\pi, \mu)$ works as follows:

      1.  $(c, s) \coloneqqDeserialize(\pi)$

      2.  $T\gets SigmaProtocol.simulate_commitment(c, s)\,.$

      3.  $c^* \gets SigmaProtocol.challenge(\mu, T)$

      4.  Check whether $c=c^*$. Output $\pctrue$ if this is the case,
          and $\pcfalse$ otherwise.

   If input parsing fails, an exception should be raised.  If
   verification fails, an exception should be raised.  Otherwise, the
   verifier outputs $\pctrue$. Optionally, the implementation can choose
   to return the parsed statement.

   ::: remark Availability of the short form While the short form as
   described here is applicable to all Sigma protocols currently covered
   by this document, it cannot be used for protocols where $T$ is not
   uniquely determined by $c$ and $s$, as is the case, e.g., for
   ZKBoo [@USENIX:GiaMadOrl16], one-out-of-many proofs [@EC:GroKoh15],
   or protocols, where a randomized signature is sent and proven correct
   subsequently, e.g., [@RSA:PoiSan16; @AC:CamChaShe08].

   A trade-off is presented, e.g., by Bobolz et al. [@EPRINT:BEHF21],
   requiring an additional algorithm to shorten a full transcript to a
   compressed form which still allows for unique reconstruction of the
   transcript. :::

2.4.  Input validation

2.5.  Composition of Sigma Protocols

   []{#sec:or-comp label="sec:or-comp"} []{#sec:and-comp label="sec:and-
   comp"} Sigma protocols can be composed to prove knowledge of multiple
   independent witnesses (_AND composition_), and for proving knowledge
   for one out of a set of witnesses (_OR composition_).  An object
   SigmaProtocol can be seen as a recursive enumeration

       enum SigmaProtocol {
         AndComposition {left: SigmaProtocol, right: SigmaProtocol},
         OrComposition  {left: SigmaProtocol, right: SigmaProtocol},
         [...]
       }

   whose instances expose the methods described above.  The dots [...]
   denote (optional) Sigma protocols instantiations that will be covered
   later.  Without loss of generality, the techniques presented in the
   following focus on the composition of two protocols.  Composition of
   multiple protocols (e.g., proving knowledge of a witness for one out
   of many statements) can be achieved by recursively applying
   composition of two protocols.

2.5.1.  AND Composition

   In this section we show how to construct a Sigma protocol proving
   knowledge of multiple independent witnesses, e.g., knowledge of
   multiple secret keys, or openings to multiple commitments.  That is,
   a Sigma protocol for the following relation:
   {\mathsf{R}_{øperatorname{and}}} = \set{ ((Y_0,Y_1),(w_0,w_1) :
   (Y_0,w_0)∈ {\mathsf{R}}_0 ~łand~ (Y_1,w_1)∈{\mathsf{R}}_1} For the
   rest of this section, the witness $w$ for the Sigma protocol will now
   be a pair $(w_0, w_1)$ of witnesses, and the associated statement $Y$
   will be a pair $(Y_0, Y_1)$ of statements, where $w_0$ is the witness
   for the statement $Y_0$, and $w_1$ is the witness for $Y_1$.

   Intuitively, the AND composition simply runs the instances of the
   different protocols to be composed in parallel, using the same
   challenge $c$ for both instances.  The verifier will then accept the
   protocol run, if and only if all instances of the partial protocols
   output $\pctrue$.

   The resulting Sigma protocol is specified by the following
   algorithms:

   *  $AndComposition.new(ctx, left, right)$: internally store left}$
      and $\texttt{right.

   *  $(\mathbf T, pstate)\gets AndComposition.prover_commit(\mathbf w)$

      1.  $(w_0,w_1)\coloneqq\mathbf w$

      2.  $(T_0,pstate_0)\getsleft.prover_commit(w_0)$

      3.  $(T_1,pstate_1)\getsright.prover_commit(w_1)$

      4.  Return $(\mathbf T,pstate) \coloneqq((T_0,
          T_1),(pstate_0,pstate_1))$

   *  $\mathbf s\gets AndComposition.prover_response(pstate, c)$

      1.  $(pstate_0,pstate_1)\coloneqqpstate$

      2.  $s_0\getsleft.prover_response(pstate_0, c)$

      3.  $s_1\getsright.prover_response(pstate_1, c)$

      4.  Return $\mathbf s\coloneqq(s_0,s_1)$

   *  $AndComposition.verifier(\mathbf T, c, \mathbf s)$

      1.  $(s_0,s_1)\coloneqq\mathbf s$.

      2.  Return $\pctrue$ if both $left.verifier(T_0,c, s_0)$ and
          $right.verifier(T_1,c, s_1)$ return $\pctrue$. Otherwise,
          return $\pcfalse$.

   *  $AndComposition.label()$ is computed as: ℎash(\texttt{\textquotesi
      ngle{}and−composition\textquotesingle} \mathbf{∣}~`left`.`label`()
       \textbf{,}~`right`.`label`()) The supported hash functions are
      described in 2.3.2 (Section 2.3.2){reference-type="ref+label"
      reference="sec:hash-registry"}.

   *  $\mathbf s\gets AndComposition.simulate_response()$ generates a
      simulated response as follows:

      1.  $s_0\getsleft.simulate_response()$

      2.  $s_1\getsright.simulate_response()$

      3.  Return $\mathbf s\coloneqq(s_0,s_1)$.

   *  $\mathbf T\gets AndComposition.simulate_commitment(c, \mathbf s)$
      works as follows:

      1.  $(s_0,s_1)\coloneqq\mathbf s$.

      2.  $T_0\getsleft.simulate_commitment(c,s_0)$

      3.  $T_1\getsright.simulate_commitment(c,s_1)$

      4.  Return $\mathbf T\coloneqq(T_0, T_1)$.

   ::: warning Witness equality Note that the AND-composition defined in
   the following gives no guarantee about equality of the witnesses: if
   the same witness is used across different clauses of the AND-
   composition, the protocol will not guarantee that they are indeed the
   same.  How to achieve such claims is discussed in 3.3 (Section 
   3.3){reference-type="ref+label" reference="sec:linear_relations"}.
   :::

2.5.2.  OR Composition

   In the following we explain how to construct a Sigma protocol proving
   knowledge of one out of a set of witnesses, for instance one of a set
   of secret keys (like ring signatures).  That is, the algorithms
   specified below constitute a Sigma protocol for the following
   relation: {\mathsf{R}_{øperatorname{or}}} = \set{
   ((Y_0,Y_1),(w_0,w_1) : (Y_0,w_0)∈ {\mathsf{R}_{øperatorname{{}}}}_0
   ~łor~ (Y_1,w_1)∈{\mathsf{R}_{øperatorname{{}}}}_1} .

   The statement $Y$ is the pair $(Y_0, Y_1)$ of the composing
   statements, and the witness $w$ is the pair $(w_0, w_1)$ of the
   witnesses for the respective relation.  One of the witness can be set
   to $\mathsf{None}$. In the following protocol specification, let $j$
   be such that $w_j$ is known to the prover, whereas without loss of
   generality $w_{1-j}$ is assumed to be unknown to the prover.

   On a high level, the protocol works as follows.  Using the simulator,
   the prover first simulates a transcript for the unknown witness
   (keeping the challenge and response of this transcript temporarily
   secret), and generates an honest commitment for the known witness.
   Having received the challenge, the prover then computes challenge for
   the known witness, depending on the received challenge and the one
   from the simulated transcript.  Having computed the response, the
   prover transfers the responses of both transcripts, as well as the
   partial challenges to the verifier, who accepts if and only if both
   instances of the partial protocols output $\pctrue$ and the partial
   challenges correctly add up to the random challenge.

   The main procedures of the resulting Sigma protocol are specified by
   the following algorithms:

   *  $OrComposition.new(ctx, left, right)$: internally store left}$ and
      $\texttt{right.

   *  $(\mathbf T, pstate)\gets OrComposition.prover_commit(\mathbf w)$:

      1.  $Prover= [left, right]$

      2.  $(w_0,w_1)\coloneqq\mathbf w$, and let $j \in \bin$ be the
          first index for which $w_{j}\neq\mathsf{None}$

      3.  $(T_j,pstate_j)\getsProver[j].prover_commit(Y_j,w_j)$

      4.  $s_{1-j}\getsProver[1-j].simulate_response()$

      5.  Choose a random $c_{1-j}$ in $\mathcal{C}$

      6.  $T_{1-j}\getsProver[1-j].simulate_commitment(c_{1-j},s_{1-j})$

      7.  Return $(\mathbf T,pstate)
          \coloneqq((T_0,T_1),(pstate_j,c_{1-j},s_{1-j}))$

   *  $\mathbf s\gets OrComposition.prover_response(pstate, c)$:

      1.  $(pstate_j,c_{1-j},s_{1-j})\coloneqqpstate$

      2.  $c_j\coloneqq c\oplus c_{1-j}$

      3.  $s_j\getsProver[j].prover_response(pstate_j, c_j)$

      4.  Return $\mathbf s\coloneqq(s_0,s_1, c_0)$.

   *  $OrComposition.verifier(\mathbf T, c, \mathbf s)$,

      1.  $(s_0, s_1, c_0)\coloneqq\mathbf s$.

      2.  $c_1\coloneqq c\oplus c_0$.

      3.  Return $\pctrue$ if both $left.verifier(T_0,c_0,s_0)$ and
          $right.verifier(T_1,c_1,s_1)$ return $\pctrue$. Otherwise,
          return $\pcfalse$.

   *  $OrComposition.label()$ is computed as: ℎash(\texttt{\textquotesin
      gle{}or−composition\textquotesingle} \mathbf{∣}~`left`.`label`()
       \textbf{,}~`right`.`label`()) The supported hash functions are
      described in 2.3.2 (Section 2.3.2){reference-type="ref+label"
      reference="sec:hash-registry"}.

   *  $\mathbf s\gets OrComposition.simulate_response()$

      1.  $(Y_0,Y_1)\coloneqq\mathbf Y$.

      2.  $s_0\getsleft.simulate_response()$

      3.  $s_1\getsright.simulate_response()$

      4.  Choose a random $c_0$ in $\mathcal{C}$.

      5.  Return $\mathbf s\coloneqq(s_0,s_1,c_0)$.

   *  $\mathbf T\gets OrComposition.simulate_commitment(c, \mathbf s)$

      1.  $(s_0,s_1,c_0)\coloneqq\mathbf s$.

      2.  $c_1\coloneqq c\oplus c_0$.

      3.  $T_0 \getsleft.simulate_commitment(c_0,s_0)$

      4.  $T_1\getsright.simulate_commitment(c_1,s_1)$

      5.  Return $\mathbf T\coloneqq(T_0,T_1)$.

3.  Sigma protocols on elliptic curves

   The following section now presents concrete instantiations for of
   Sigma protocols over elliptic curves.

   ::: remark Protocols for residue classes Because of their dominance,
   the presentation in the following focuses on proof goals over
   elliptic curves, therefore leveraging additive notation.  For prime-
   order subgroups of residue classes, all notation needs to be changed
   to multiplicative, and references to elliptic curves (e.g.,
   $\textsf{curve}$) need to be replaced by their respective
   counterparts over residue classes. :::

3.1.  Ciphersuite Registry

   We advise for the use of prime-order elliptic curves of size either
   256 or 512 bits, depending on the desired security of the upper
   layers in the protocol
   // For instance, proving a DH relation with one fixed group element
   // such as a public key, might expose the protocol to cryptanalytic
   // attacks such as Brown-Gallant [@EPRINT:BroGal04] and Cheon's
   // attack [@EC:Cheon06], and some implementations might opt for
   // larger curve sizes.  We consider these attacks out of scope for
   // this standardization effort, and believe this analysis should be
   // deferred to the concrete security study of the larger protocol..

   ::: center Curve Identifier Security Level Sources -----------
   ---------------- ---------------- ------------------------- P-521
   '-p-521' 256 [@fips2] P-256 '-p-256' 128 [@fips2] secp256k1
   '-secp256k1' 128 [@SECG] Ristretto '-ristretto' 128 [@cfrg-ristretto-
   decaf] BLS12-381 '-bls12-381' 128 [@bls12] :::

   We denote with $\GG$ the prime-order group of the elliptic curve,
   with $\FF_p$ the scalar field, and with $G$ the generator of $\GG$
   chosen as per the curve parameters.  We assume that all above curve
   parameters also provide the following group operations: check for
   equality, identity, addition, and scalar multiplication.  Optionally,
   implementation might implement Pippenger's algorithm [@pippenger] for
   multi-scalar multiplication.  In addition, we consider:

   *  an identifier for the curve, chosen from the table above, and
      denoted $\textsf{curve}$;

   *  a deterministic sub-procedure $a \coloneqqFromBytes(b)$, taking as
      input a bit string $b$ of length $\ensuremath{\SI{32}{\byte}}$,
      and mapping it into an element $a \sample \FF_p$;

   *  a deterministic sub-procedure $s \coloneqqSerialize(P)$, taking as
      input a group element $P \in \GG$ and returning a fixed-length
      sequence of bits.  For elliptic curve groups, Serialize must
      provide a compressed representation of the _affine_
      representation, such as the $x$-coordinate of $P$ and one bit
      determining the sign of $y$.

   *  a deterministic sub-procedure $P \coloneqqDeserialize(s)$, taking
      a (fixed-length and curve-dependent) sequence of bits and
      returning an elliptic curve point.  This procedure may raise an
      exception or output $\mathsf{None}$ if the conversion fails.

3.2.  Basic Sigma Protocols in prime-order groups

   We describe an abstract class for proving knowledge of a preimage
   under an arbitrary _group homomorphism_, which is a mapping between
   two groups respecting the structure of the groups.  In particular, as
   will be discussed in 3.4 (Section 3.4){reference-type="ref+label"
   reference="sec:instantiations"}, many statements related to discrete
   logarithms or representations in groups of prime order, can be
   expressed as statements over group homomorphisms.  For an in-depth
   discussion of the underlying theory we refer to Cramer [@cramer97].

   ::: definition *Definition 1*. _For two groups $\GG_1,\GG_2$, a
   function $\varphi:\GG_1\to\GG_2:x\mapsto\varphi(x)$ is a *(group)
   homomorphism_, if and only if for all $a,b\in\GG_1$ it holds that
   $\varphi(a+b)=\varphi(a)+\varphi(b)$.* :::

   Readers not familiar with the notation of group homomorphism may
   think of $\varphi$ as a linear function from $n$ elements into $m$
   elements.

   ::: example Discrete logarithm equalityphi_DLEQ Looking at the
   relation ${\mathsf{R}_{\operatorname{dleq}}}$, the relevant
   homomorphism is given by: φ_{øperatorname{dleq}} : \FF_p→\GG^2 : w↦
   (wG,wH) . If equality of discrete logarithms within _different_
   groups of the same prime order $p$ is to be proven, the homomorphism
   to be considered would be: φ_{øperatorname{dleq}}' :
   \FF_p→\GG_1×\GG_2 : w↦ (wG,wH) , where $G$ and $H$ would now be
   generators for $\GG_1$ and $\GG_2$, respectively.  All the techniques
   discussed in the remainder of this spec equally apply to both cases.
   :::

   ::: example Representationphi_REP Looking at the relation
   ${\mathsf{R}_{\operatorname{rep}}}$, the relevant homomorphism is
   given by: φ_{øperatorname{rep}} : \FF_p^2→\GG : (w_1,w_2)↦ w_1 G +
   w_2 H . :::

   []{#sec:sigma-dlog label="sec:sigma-dlog"} We provide a generic
   template for all Sigma protocols for statements of the following form
   over DLOG groups: {\mathsf{R}_{øperatorname{dlog}}}=\set{((Y_1,\dots,
   Y_m),(w_1,\dots,w_n)) ∈ \GG^m × \FF_p^n:
   (Y_1,\dots,Y_m)=φ(w_1,\dots,w_n)} where $\varphi:\FF_p^n\to\GG^m$ is
   a group homomorphism.

   ::: remark Selective disclosure of witnesses Note that in the
   following descriptions, all witnesses are assumed to be kept secret,
   i.e., none of them is disclosed to the verifier.  In case it is
   required to disclose $w_j$, as is the case, e.g., in the context of
   attribute-based credential systems, the relation to be proven can be
   rewritten as follows: {\mathsf{R}_{øperatorname{dlog}}}'=\set{
   \begin{array}{r}
   ((Y_1',\dots,Y_m')),(w_1,\dots,w_{j−1},w_{j+1},\dots,w_n)) ∈ \GG^m ×
   \FF_p^{n−1}: ~~~~~~~~~~~~\\
   (Y_1',\dots,Y_m')=ψ(w_1,\dots,w_{j−1},w_{j+1},\dots,w_n) \end{array}
   } where $$\begin{aligned} (Y_1',\dots,Y_m') &:=
   (Y_1,\dots,Y_m)-\varphi(0,\dots,0,w_j,0,\dots,0)\,\text{ and}
   \psi(w_1,\dots,w_{j-1},w_{j+1},\dots,w_n) &:=
   \varphi(w_1,\dots,w_{j-1},0,w_{j+1},\dots,w_n)\,.

   \end{aligned}$$ :::

   However, the following _defines neither the morphism nor the label
   associated to the protocol_. These will be defined later in the
   specific protocols.

   *  $DlogTemplate.new(ctx, \mathbf Y)$ internally stores $\mathbf Y$
      and ctx.

   *  []{#item:basic:p1 label="item:basic:p1"} $(\mathbf T, pstate)
      \gets DlogTemplate.prover_commit(\mathbf w)$ consists of the
      following steps:

      1.  []{#item:basic:p1:randomness label="item:basic:p1:randomness"}
          Sample random elements $r_1,\dots,r_n\sample\FF_p$

      2.  $\mathbf
          T\coloneqq(T_1,\dots,T_m)\coloneqq\varphi(r_1,\dots,r_n)$

      3.  $pstate\coloneqq(r_1,\dots,r_n)$

      4.  Return $(\mathbf T,pstate)$

   *  []{#item:basic:p2 label="item:basic:p2"} $\mathbf s\gets
      DlogTemplate.prover_response(pstate,c)$ proceeds as follows:

      1.  $(r_1,\dots,r_n)\coloneqqpstate$

      2.  $(w_1,\dots,w_n)\coloneqq\mathbf w$

      3.  $e \coloneqqFromBytes(c)$.

      4.  For $i=1,\dots,n$: $s_i\coloneqq r_i+e w_i$

      5.  Return $\mathbf s\coloneqq(s_1,\dots,s_n)$.

   *  $DlogTemplate.label()$ return $morphism_label()$.

   *  []{#item:basic:v label="item:basic:v"}
      $DlogTemplate.verifier(\mathbf T,c,\mathbf s)$ proceeds as
      follows:

      1.  $(s_1, \dots, s_n) \coloneqq\mathbf s$

      2.  $(T_1, \dots, T_m) \coloneqq\mathbf T$

      3.  $e \coloneqqFromBytes(c)$.

      4.  []{#item:basic:v:checks label="item:basic:v:checks"} For
          $i=1,\dots,n$: check $s_i\in\FF_p$

      5.  For $j=1,\dots,m$: check $T_j\in\GG$

      6.  Return $\pctrue$ if $(T_1 + eY_1,\dots,T_m + eY_m) =
          \varphi(s_1,\dots,s_n)$; $\pcfalse$ otherwise

   *  $\mathbf s\gets DlogTemplate.simulate_response()$:

      1.  Sample random elements $s_1,\dots,s_n\sample\FF_p$

      2.  Return $(s_1, \dots, s_n)$

   *  []{#item:basic:sim label="item:basic:sim"} $\mathbf T\gets
      DlogTemplate.simulate_commitment(c, \mathbf s)$:

      1.  $(Y_1,\dots,Y_m)\coloneqq\mathbf Y$.

      2.  []{#item:basic:sim:s label="item:basic:sim:s"}
          $(s_1,\dots,s_n) \coloneqq\mathbf s$.

      3.  $e \coloneqqFromBytes(c)$.

      4.  $(T_1,\dots,T_m) \coloneqq\varphi(s_1,\dots,s_n) -
          e\cdot(Y_1,\dots,Y_m)$.

      5.  Output $\mathbf T\coloneqq(s_1,\dots,s_n)$.

3.3.  Advanced: proving linear relations

   While the above protocol allows one to efficiently prove knowledge of
   a pre-image under a homomorphism, many protocols found in the
   literature require one to prove relations among witnesses.
   Specifically, they require to prove relations like the following: {\m
   athsf{R}_{øperatorname{lin}}}=\set{((Y_1,\dots,Y_m),(w_1,\dots,w_n))
   : \begin{array}{c} (Y_1,\dots,Y_m)=φ(w_1,\dots,w_n) \\
   A⋅(w_1,\dots,w_n)^⊺ = (b_1,\dots,b_k)^⊺\end{array}} , where the
   matrix $A\in\FF_p^{k\times n}$ and vector $(b_1,\dots,b_k)\in\FF_p^k$
   specify the system of linear equations.

   In the following, we sketch how such relations can be translated into
   relations of the form discussed in 3.2 (Section 3.2){reference-
   type="ref+label" reference="sec:basic_sigma"}. We assume that $A$ is
   of the following form: A = łeft(\begin{array}{cccccccc} a_{11} &
   \dots & a_{1k} & 1 & 0 & 0 & \dots & 0\\ a_{21} & \dots & a_{2k} & 0
   & 1 & 0 & \dots & ⋮\\ ⋮ & & ⋮ & ⋮ & & ⋮& & 0\\ ⋮ & & ⋮ & ⋮ & & 0 & 1
   & 0\\ a_{k1} & \dots & a_{kk} & 0 & \dots & \dots & 0 & 1\\
   \end{array}\right) Note that this is without loss of generality.  If
   the system of linear equations has a different form, the above form
   can always be achieved using Gaussian elimination [@shoup08
   Sec. 14.4] and re-ordering of the witnesses.  Note that we only need
   to consider the case where $k<n$, as otherwise the linear equations
   would uniquely determine the witnesses, which is not desirable in our
   context.

   The following relation ${\mathsf{R}_{\operatorname{lin}}}'$ is now
   equivalent to that specified by ${\mathsf{R}_{\operatorname{lin}}}$: 
   {\mathsf{R}_{øperatorname{lin}}}'=\set{((Y_1,\dots,Y_m),(w_1,\dots,w_
   {n−k})) : (Y_1,\dots,Y_m)=ψ(w_1,\dots,w_{n−k})} where \begin{aligned}
   ψ(w_1,\dots,w_{n−k}) &:= φ(w_1,\dots,w_{n−k},−∑_{i=1}^{n−k}a_{1i}w_i,
   \dots,−∑_{i=1}^{n−k}a_{ki}w_i) \text{ and}\\ (Y_1',\dots,Y_m') &:=
   (Y_1,\dots,Y_m) − φ(0,\dots,0,b_1,\dots,b_k) . \end{aligned}

3.4.  Examples

   Let $\GG$ be a group over an elliptic curve with prime order $p$.
   Denote with $G \in \GG$ a generator of $\GG$.

3.4.1.  Schnorr signatures

   Schnorr signatures, also known as Schnorr proofs or DLOG proofs,
   prove knowledge of the discrete logarithm $w\in \FF_p$ of a point
   $Y=wG$ in base $G$.

   *  $\varphi:\FF_p\to\GG:w\mapsto wG$

   *  $Schnorr.morphism_label()$: return: ℎash(\texttt{\textquotesingle{
      }schnorrsig\textquotesingle} \textbf{,}~\textsf{curve} \mathbf{∣}~
      `Serialize`(G)  \textbf{,}~`Serialize`(Y))

   For a description of this proof goal in the general case of residue
   classes, we also refer to [@zkproof-reference 1.4.1].

3.4.2.  Discrete logarithm equality

   So-called DLEQ proofs prove equality of the discrete logarithm, that
   is: $Y_1 = wG$ and $Y_2 = wH$.

   *  $\varphi:\FF_p\to\GG^2:w\mapsto (wG,wH)$

   *  $Dleq.morphism_label()$: return ℎash(\texttt{\textquotesingle{}dle
      q\textquotesingle} \textbf{,}~\textsf{curve} \mathbf{∣}~`Serialize
      `(G)  \textbf{,}~`Serialize`(H)  \textbf{,}~`Serialize`(Y_1)
       \textbf{,}~`Serialize`(Y_2))

3.4.3.  Diffie-Hellman

   Let $\GG$ be a group over an elliptic curve with prime order $p$.
   Proving knowledge of the exponents of a valid Diffie-Hellman triple
   means proving knowledge of $w_1,w_2\in\FF_p$ such that $Y_1=w_1G$,
   $Y_2=w_2G$, and $Y_3=w_1 w_2 G$. The mapping
   $\FF_p^2\to\GG^3:(w_1,w_2)\mapsto (w_1G,w_2G,w_1w_2G)$ is not a
   homomorphism, and consequently the basic protocol presented before
   cannot be deployed directly.  However, the required multiplicative
   relation can be proven by observing that the proof goal is equivalent
   to $Y_1=w_1G$, $Y_2=w_2G$, and $Y_3=w_2Y_1$, leading the homomorphism

   *  $\varphi:\FF_p^2\to\GG^3:(w_1,w_2)\mapsto(w_1G,w_2G,w_2Y_1)$

   *  $Dh.morphism_label()$ return: ℎash(\texttt{\textquotesingle{}diffi
      e−hellman\textquotesingle} \textbf{,}~\textsf{curve} \mathbf{∣}~`S
      erialize`(G)  \textbf{,}~`Serialize`(Y_1)
       \textbf{,}~`Serialize`(Y_2))

   As shown in this example, and in contrast to linear relations,
   multiplicative relations among witnesses typically require a
   reformulation of the proof goal.

3.4.4.  Representation

   Let $\GG$ be a group over an elliptic curve of prime order $p$, and
   let $G_1, \dots, G_m$ be generators of $\GG$. Proving knowledge of a
   valid opening of a Pedersen commitment means proving knowledge of
   $w_1,w_2, \dots, w_m\in\FF_p$ such that $Y=w_1G_1 + w_2G_2 + \dots +
   w_m G_m$.

   *  $\varphi:\FF_p^m\to\GG:(w_1,w_2, \dots, w_m)\mapsto \sum_i w_iG_i$

   *  $Rep.morphism_label()$ returns ℎash(\texttt{\textquotesingle{}repr
      esentation\textquotesingle} \textbf{,}~\textsf{curve} \mathbf{∣}~`
      Serialize`(G_1)  \textbf{,}~⋅s  \textbf{,}~`Serialize`(G_m)
       \textbf{,}~`Serialize`(Y))

   ::: example Range proofs via bit decomposition Let $\GG$ be a cyclic
   group of prime order $p$, and let $G$ and $H$ be generators of $\GG$,
   and let $\ell$ be a non-negative integer satisfying $\ell<\log_2 p$.
   Consider the following relation: {\mathsf{R}_{øperatorname{range}}} =
   \set{łeft(Y,(w_1,w_2))\right)~:~Y=w_1 G +w_2 H ~łand~ w_1∈[0,2^ℓ)} .
   Multiple techniques for proving that a secret witness lies within a
   certain range, cf. Morais et al. [@range-proof-survey] for a survey.
   We will use the so-called _bit decomposition_ approach.

   To do so, the prover computes $w_{1,i}\in\set{0,1}$ for
   $i=0,\dots,\ell-1$ such that $w_1=\sum_{i=0}^{\ell-1}2^iw_{1,i}$, and
   computes commitments to those individual bits, i.e.,
   $Y_i=w_{1,i}G+w_{2,i}H$ for $w_{2,i}\sample\FF_p$. Furthermore, it
   sets $w^*=w_2-\sum_{i=0}^{\ell-1}2^iw_{2,i}$.

   Assuming that the discrete logarithm problem is hard in $\GG$, the
   above relation is now equivalent to the following relation:
   $$\begin{aligned} {\mathsf{R}_{\operatorname{range}}}' =
   \bigg{\left((Y,(Y_i)_{i=0}^{\ell-1}),(w_1,w_2,(w_{2,i})_{i=0}^{\ell-
   1}),w^*)\right)~:~ Y=w_1 G +w_2 H ~\land~
   Y-\sum_{i=0}^{\ell-1} 2^iY_i = w^* H ~\land~
   \bigwedge_{i=0}^{\ell-1} \left(Y_i=w_{2,i}H ~\lor~ Y_i-
   G=w_{2,i}H\right)\bigg}\,.

   \end{aligned}$$

   It can now be seen that the above ensures knowledge of the witnesses
   $w_1$ hidden within $Y$. Furthermore, we guarantee that the values
   hidden within $Y_i$ correctly add up to $w_1$, i.e., that $w_1-
   \sum_{i=0}^{\ell-1}2^iw_{1,i}=0$. Finally, the two clauses ensure
   that each $Y_i$ is a commitment to either $0$ or $1$, thus implying
   the bound on $w_1$.

   The different clauses can finally be composed using nested protocol
   compositions from 2.5 (Section 2.5){reference-type="ref+label"
   reference="sec:composition"}. :::

3.5.  Batch verification

   The batchable form can take advantage of the following fact.  Given
   $\ell$ verification equations of the form: T_i + c_i Y_i = ∑_j s_j
   G_{i,j} for $i=1, \dots,\ell$, the verifier can sample a random
   vector of coefficients $\mathbf a \in \FF_p^\ell$ and instead test:
   łeft(∑_{i=1}^{ℓ} a_i T_i\right) + łeft(∑_{i=1}^{ℓ} a_i ⋅ c_i Y_i
   \right) = łeft(∑_{i=1}^{ℓ} a_i ⋅ ∑_j s_j G_{i,j}\right).  If the
   matrix $G_{i, j}$ of generators has identical rows, by linearity the
   right-hand side can be computed as a single scalar product.  If the
   statements $Y_i$'s have identical rows, by linearity the second term
   in the equation can be computed as a single scalar product.

   In any case, the test can be efficiently implemented as a single
   multiscalar multiplication, minimizing the number of group operations
   needed: łeft(∑_{i=1}^{ℓ} a_i T_i\right) + łeft(∑_{i=1}^{ℓ} (a_i ⋅
   c_i) Y_i \right) + łeft(∑_{i=1}^{ℓ}∑_j (−a_i ⋅ s_j) G_{i,j}\right) =
   0.

   The random vector $\mathbf a$ can be _deterministically_ generated by
   fixing $a_1 \coloneqq 1$ and setting $(a_2, \dots, a_{\ell})
   \coloneqq\prg(\hash(c\,\textbf{,}~\mathbf s))$ [@bip-schnorr].

4.  Encoding the statement

   Statements in Sigma protocols take the form of a labeled binary tree:
   Statement is either:

   *  a label [AND]{.sans-serif}, or [OR]{.sans-serif}, and two children
      [left]{.sans-serif} and [right]{.sans-serif} of type Statement

   *  a $StatementLeaf$ instance.  Objects of this type depend on the
      specific algebraic setting used, and will be treated later.

   Statements are serialized depth-first.  There are many different
   options for serialization that could be considered:

   *  Concise Binary Object Representation (CBOR) RFC7049
      (https://datatracker.ietf.org/doc/html/rfc7049)

   *  The zk proof Reference document provides a serialization document
      for r1cs [@zkproof-reference 3.4.2], but there is nothing in it.

5.  Additional proof types

   Other protocols are not included here and are not part of the scope
   of the current version of this spec.

   *  mpc-in-the-head protocol such as ZKBoo [@USENIX:GiaMadOrl16]

   *  one-out-of-many proofs such as [@EC:GroKoh15]

   *  lwe-based sigma protocol [@C:AttCraKoh21]

   *  syndrome decoding and LPN [@C:Stern93; @AC:JKPT12]

Acknowledgments

   Jan Bobolz, Mary Maller, Ivan Visconti, Yuwen Zhang.

Authors' Addresses

   Michele Orrù
   CNRS
   Email: m@orru.net


   Stephan Krenn
   AIT
   Email: stephan.krenn@ait.ac.at
